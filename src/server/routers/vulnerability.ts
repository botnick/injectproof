// VibeCode â€” Vulnerability Router
// Query, filter, update status, and get evidence for vulnerabilities

import { z } from 'zod';
import { router, protectedProcedure } from '@/server/trpc';
import { TRPCError } from '@trpc/server';

export const vulnerabilityRouter = router({
    /** List vulnerabilities with filtering */
    list: protectedProcedure
        .input(z.object({
            page: z.number().min(1).default(1),
            pageSize: z.number().min(1).max(100).default(20),
            targetId: z.string().optional(),
            scanId: z.string().optional(),
            severity: z.string().optional(),
            category: z.string().optional(),
            status: z.string().optional(),
            search: z.string().optional(),
            cweId: z.string().optional(),
        }).optional())
        .query(async ({ ctx, input }) => {
            const { page = 1, pageSize = 20, targetId, scanId, severity, category, status, search, cweId } = input || {};

            const where: Record<string, unknown> = {};
            if (targetId) where.targetId = targetId;
            if (scanId) where.scanId = scanId;
            if (severity) where.severity = severity;
            if (category) where.category = category;
            if (status) where.status = status;
            if (cweId) where.cweId = cweId;
            if (search) {
                where.OR = [
                    { title: { contains: search } },
                    { affectedUrl: { contains: search } },
                    { parameter: { contains: search } },
                ];
            }

            const [items, total] = await Promise.all([
                ctx.prisma.vulnerability.findMany({
                    where: where as any,
                    include: {
                        target: { select: { id: true, name: true, baseUrl: true } },
                        scan: { select: { id: true, scanType: true, createdAt: true } },
                    },
                    orderBy: [
                        { severity: 'asc' },
                        { createdAt: 'desc' },
                    ],
                    skip: (page - 1) * pageSize,
                    take: pageSize,
                }),
                ctx.prisma.vulnerability.count({ where: where as any }),
            ]);

            return { items, total, page, pageSize, totalPages: Math.ceil(total / pageSize) };
        }),

    /** Get vulnerability by ID with full details */
    getById: protectedProcedure
        .input(z.string())
        .query(async ({ ctx, input }) => {
            const vuln = await ctx.prisma.vulnerability.findUnique({
                where: { id: input },
                include: {
                    target: { select: { id: true, name: true, baseUrl: true } },
                    scan: { select: { id: true, scanType: true, createdAt: true } },
                    evidence: { orderBy: { order: 'asc' } },
                },
            });

            if (!vuln) {
                throw new TRPCError({ code: 'NOT_FOUND', message: 'Vulnerability not found' });
            }

            return vuln;
        }),

    /** Update vulnerability status */
    updateStatus: protectedProcedure
        .input(z.object({
            id: z.string(),
            status: z.enum(['open', 'confirmed', 'fixed', 'false_positive', 'accepted', 'reopened']),
            notes: z.string().optional(),
        }))
        .mutation(async ({ ctx, input }) => {
            const vuln = await ctx.prisma.vulnerability.update({
                where: { id: input.id },
                data: {
                    status: input.status,
                    notes: input.notes,
                    fixedAt: input.status === 'fixed' ? new Date() : undefined,
                    verifiedAt: input.status === 'confirmed' ? new Date() : undefined,
                },
            });

            await ctx.prisma.auditLog.create({
                data: {
                    userId: ctx.user!.userId,
                    action: 'update_vuln',
                    resource: 'vulnerability',
                    resourceId: input.id,
                    details: JSON.stringify({ status: input.status, notes: input.notes }),
                },
            });

            return vuln;
        }),

    /** Get vulnerability statistics */
    stats: protectedProcedure
        .input(z.object({
            targetId: z.string().optional(),
            scanId: z.string().optional(),
        }).optional())
        .query(async ({ ctx, input }) => {
            const where: Record<string, unknown> = {};
            if (input?.targetId) where.targetId = input.targetId;
            if (input?.scanId) where.scanId = input.scanId;

            const [bySeverity, byCategory, byStatus, total] = await Promise.all([
                ctx.prisma.vulnerability.groupBy({
                    by: ['severity'],
                    where: where as any,
                    _count: { id: true },
                }),
                ctx.prisma.vulnerability.groupBy({
                    by: ['category'],
                    where: where as any,
                    _count: { id: true },
                }),
                ctx.prisma.vulnerability.groupBy({
                    by: ['status'],
                    where: where as any,
                    _count: { id: true },
                }),
                ctx.prisma.vulnerability.count({ where: where as any }),
            ]);

            return {
                total,
                bySeverity: bySeverity.map(s => ({ severity: s.severity, count: s._count.id })),
                byCategory: byCategory.map(c => ({ category: c.category, count: c._count.id })),
                byStatus: byStatus.map(s => ({ status: s.status, count: s._count.id })),
            };
        }),
});
